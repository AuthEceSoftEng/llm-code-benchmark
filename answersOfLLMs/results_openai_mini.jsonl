{"timestamp_utc": "2025-09-24T15:57:31.929691", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 0, "question": "Write find_balanced_sublist(arr) that returns the longest even-length contiguous sublist where sum of first half equals sum of second half. Return empty list if none exists.\n\nReturn only the Python function code with no explanations, comments, or markdown formatting.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 13.921195983886719, "response": "def find_balanced_sublist(arr):\n    n = len(arr)\n    if n < 2:\n        return []\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + arr[i]\n    max_len = n if n % 2 == 0 else n - 1\n    for L in range(max_len, 0, -2):\n        half = L // 2\n        for i in range(0, n - L + 1):\n            mid = i + half\n            if prefix[mid] - prefix[i] == prefix[i + L] - prefix[mid]:\n                return arr[i:i + L]\n    return []", "error": null, "raw_item": {"task_id": "custom_find_balanced_sublist", "prompt": "Write find_balanced_sublist(arr) that returns the longest even-length contiguous sublist where sum of first half equals sum of second half. Return empty list if none exists.\n\nReturn only the Python function code with no explanations, comments, or markdown formatting.", "entry_point": "find_balanced_sublist", "canonical_solution": "def find_balanced_sublist(arr: list[int]) -> list[int]:\n    n = len(arr)\n    for length in range(n, 1, -1):\n        if length % 2 != 0:\n            continue\n        for start in range(n - length + 1):\n            sub = arr[start:start+length]\n            half = length // 2\n            if sum(sub[:half]) == sum(sub[half:]):\n                return sub\n    return []", "test": [{"input": [[1, 2, 3, 3, 2, 1]], "output": [1, 2, 3, 3, 2, 1]}, {"input": [[5, 1, 2, 1, 5]], "output": []}, {"input": [[1, 1, 1, 1]], "output": [1, 1, 1, 1]}, {"input": [[1, 2, 3]], "output": []}, {"input": [[]], "output": []}, {"input": [[3, 0, 3, 0, 3]], "output": [3, 0, 3, 0]}, {"input": [[2, 1, 1, 2, 3, 4]], "output": [2, 1, 1, 2]}, {"input": [[1, 5, 3, 7]], "output": []}, {"input": [[0, 0, 0, 0]], "output": [0, 0, 0, 0]}]}}
{"timestamp_utc": "2025-09-24T15:57:49.921480", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 1, "question": "Write merge_by_priority(items_a, items_b) that merges two lists of (id, priority) pairs. Keep highest priority for each unique id. Return sorted by priority descending. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 16.989907026290894, "response": "def merge_by_priority(items_a, items_b):\n    merged = {}\n    for id_, priority in items_a:\n        if id_ not in merged or priority > merged[id_]:\n            merged[id_] = priority\n    for id_, priority in items_b:\n        if id_ not in merged or priority > merged[id_]:\n            merged[id_] = priority\n    return sorted(merged.items(), key=lambda x: x[1], reverse=True)", "error": null, "raw_item": {"task_id": "custom_merge_by_priority", "prompt": "Write merge_by_priority(items_a, items_b) that merges two lists of (id, priority) pairs. Keep highest priority for each unique id. Return sorted by priority descending. Return only the Python function code with no explanations.", "entry_point": "merge_by_priority", "canonical_solution": "def merge_by_priority(items_a: list[tuple[str, int]], items_b: list[tuple[str, int]]) -> list[tuple[str, int]]:\n    combined = items_a + items_b\n    best = {}\n    for id, priority in combined:\n        if id not in best or priority > best[id]:\n            best[id] = priority\n    return sorted(best.items(), key=lambda x: -x[1])", "test": [{"input": [[["item1", 2], ["item2", 5]], [["item2", 3], ["item3", 4]]], "output": [["item2", 5], ["item3", 4], ["item1", 2]]}, {"input": [[], []], "output": []}, {"input": [[["a", 1]], [["a", 10]]], "output": [["a", 10]]}, {"input": [[["x", 5], ["y", 3]], [["z", 7], ["y", 6]]], "output": [["z", 7], ["y", 6], ["x", 5]]}, {"input": [[["a", 1], ["b", 2]], []], "output": [["b", 2], ["a", 1]]}]}}
{"timestamp_utc": "2025-09-24T15:58:05.006025", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 2, "question": "Write parse_env_config(lines) that parses environment variable lines into dict. Ignore lines starting with '#', lines without '=', and empty keys. Keep last occurrence of duplicate keys. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 14.082011938095093, "response": "def parse_env_config(lines):\n    result = {}\n    for line in lines:\n        if not isinstance(line, str):\n            continue\n        s = line.strip()\n        if not s or s.startswith('#'):\n            continue\n        if '=' not in line:\n            continue\n        key, _, value = line.partition('=')\n        key = key.strip()\n        if not key:\n            continue\n        result[key] = value.strip()\n    return result", "error": null, "raw_item": {"task_id": "custom_parse_env_config", "prompt": "Write parse_env_config(lines) that parses environment variable lines into dict. Ignore lines starting with '#', lines without '=', and empty keys. Keep last occurrence of duplicate keys. Return only the Python function code with no explanations.", "entry_point": "parse_env_config", "canonical_solution": "def parse_env_config(lines: list[str]) -> dict[str, str]:\n    env = {}\n    for line in lines:\n        line = line.strip()\n        if not line or line.startswith(\"#\") or \"=\" not in line:\n            continue\n        key, value = line.split(\"=\", 1)\n        if key:\n            env[key] = value\n    return env", "test": [{"input": [["DB_HOST=localhost", "DB_PORT=5432", "#comment", "DB_HOST=remotehost", "=fail", "INVALID", ""]], "output": {"DB_HOST": "remotehost", "DB_PORT": "5432"}}, {"input": [["A=1", "B=2", "C=3"]], "output": {"A": "1", "B": "2", "C": "3"}}, {"input": [["# just a comment", "=", "==", "KEY_ONLY=", "NO_EQUALS"]], "output": {"KEY_ONLY": ""}}, {"input": [[]], "output": {}}, {"input": [["k1=v1", "k1=v2", "k1=v3"]], "output": {"k1": "v3"}}]}}
{"timestamp_utc": "2025-09-24T15:58:23.917856", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 3, "question": "Write minimal_partition_difference(nums) that partitions a list into two groups to minimize absolute difference of their sums. Handle empty list case explicitly. Use DP subset sum approach. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 17.910326957702637, "response": "def minimal_partition_difference(nums):\n    if not nums:\n        return 0\n    total = sum(nums)\n    dp = 1\n    for num in nums:\n        if num < 0:\n            raise ValueError(\"nums must contain non-negative integers\")\n        dp |= dp << num\n    half = total // 2\n    for s in range(half, -1, -1):\n        if (dp >> s) & 1:\n            return total - 2 * s", "error": null, "raw_item": {"task_id": "custom_minimal_partition_difference", "prompt": "Write minimal_partition_difference(nums) that partitions a list into two groups to minimize absolute difference of their sums. Handle empty list case explicitly. Use DP subset sum approach. Return only the Python function code with no explanations.", "entry_point": "minimal_partition_difference", "canonical_solution": "def minimal_partition_difference(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    total = sum(nums)\n    target = total // 2\n    possible = {0}\n    for num in nums:\n        possible |= {x + num for x in possible}\n    best = max(x for x in possible if x <= target)\n    return total - 2 * best", "test": [{"input": [[1, 2, 3, 9]], "output": 3}, {"input": [[1, 2, 3, 4, 5]], "output": 1}, {"input": [[10, 10]], "output": 0}, {"input": [[7]], "output": 7}, {"input": [[]], "output": 0}, {"input": [[1, 1, 1, 1, 1, 1]], "output": 0}, {"input": [[100, 99, 98, 1]], "output": 96}]}}
{"timestamp_utc": "2025-09-24T15:58:33.235387", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 4, "question": "Write normalize_user_roles(users) where users is a dict mapping each user to a LIST of roles. Invert to map each role to list of users. Remove duplicate users per role and sort user lists alphabetically. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 8.316102981567383, "response": "def normalize_user_roles(users):\n    role_map = {}\n    for user, roles in users.items():\n        for role in roles:\n            role_map.setdefault(role, []).append(user)\n    for role, user_list in list(role_map.items()):\n        role_map[role] = sorted(set(user_list))\n    return role_map", "error": null, "raw_item": {"task_id": "custom_normalize_user_roles", "prompt": "Write normalize_user_roles(users) where users is a dict mapping each user to a LIST of roles. Invert to map each role to list of users. Remove duplicate users per role and sort user lists alphabetically. Return only the Python function code with no explanations.", "entry_point": "normalize_user_roles", "canonical_solution": "def normalize_user_roles(users: dict[str, list[str]]) -> dict[str, list[str]]:\n    role_to_users = {}\n    for user, roles in users.items():\n        for role in set(roles):  # remove duplicates\n            if role not in role_to_users:\n                role_to_users[role] = []\n            role_to_users[role].append(user)\n    for role in role_to_users:\n        role_to_users[role].sort()\n    return role_to_users", "test": [{"input": [{"alice": ["admin", "editor"], "bob": ["editor", "admin"], "charlie": ["viewer"]}], "output": {"admin": ["alice", "bob"], "editor": ["alice", "bob"], "viewer": ["charlie"]}}, {"input": [{"diana": [], "eva": ["user", "user"], "frank": ["user"]}], "output": {"user": ["eva", "frank"]}}, {"input": [{"a": ["x"], "b": ["y"], "c": ["x", "y"]}], "output": {"x": ["a", "c"], "y": ["b", "c"]}}, {"input": [{}], "output": {}}]}}
{"timestamp_utc": "2025-09-24T15:59:05.409680", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 5, "question": "Write can_form_expression(digits, target) that checks if inserting '+' or '-' operators (or nothing) between digits can reach target value. Use recursive DFS. Must handle multi-digit numbers. Return complete Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 31.172542810440063, "response": "def can_form_expression(digits, target):\n    \"\"\"\n    Check if by inserting '+' or '-' or nothing between digits we can form an expression equal to target.\n    digits can be a string of digits or an iterable of digits/ints.\n    Returns True if such an expression exists, False otherwise.\n    \"\"\"\n    # normalize digits to a string\n    if isinstance(digits, (list, tuple)):\n        digits = ''.join(str(d) for d in digits)\n    elif not isinstance(digits, str):\n        digits = str(digits)\n\n    n = len(digits)\n    if n == 0:\n        return target == 0\n\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dfs(start, current):\n        # start: next index to partition from\n        # current: value of expression built so far\n        if start == n:\n            return current == target\n\n        for end in range(start + 1, n + 1):\n            num_str = digits[start:end]\n            # allow conversion like \"01\" -> 1; if you want to disallow leading zeros uncomment next lines:\n            # if len(num_str) > 1 and num_str[0] == '0':\n            #     break\n            num = int(num_str)\n            if start == 0:\n                # first number, cannot prepend operator\n                if dfs(end, num):\n                    return True\n            else:\n                if dfs(end, current + num):\n                    return True\n                if dfs(end, current - num):\n                    return True\n        return False\n\n    return dfs(0, 0)", "error": null, "raw_item": {"task_id": "custom_can_form_expression", "prompt": "Write can_form_expression(digits, target) that checks if inserting '+' or '-' operators (or nothing) between digits can reach target value. Use recursive DFS. Must handle multi-digit numbers. Return complete Python function code with no explanations.", "entry_point": "can_form_expression", "canonical_solution": "def can_form_expression(digits: str, target: int) -> bool:\n    def dfs(index: int, current_value: int, expression: str) -> bool:\n        if index == len(digits):\n            return current_value == target\n        for end in range(index + 1, len(digits) + 1):\n            num_str = digits[index:end]\n            num = int(num_str)\n            if index == 0:\n                if dfs(end, num, num_str):\n                    return True\n            else:\n                if dfs(end, current_value + num, expression + '+' + num_str):\n                    return True\n                if dfs(end, current_value - num, expression + '-' + num_str):\n                    return True\n        return False\n    return dfs(0, 0, \"\")", "test": [{"input": ["123", 6], "output": true}, {"input": ["105", 5], "output": true}, {"input": ["123", 123], "output": true}, {"input": ["123", 100], "output": false}, {"input": ["000", 0], "output": true}, {"input": ["1", 1], "output": true}, {"input": ["1", 2], "output": false}]}}
{"timestamp_utc": "2025-09-24T15:59:21.229099", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 6, "question": "Write has_balanced_bits(n) that returns True if binary representation of n has equal number of 0s and 1s. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 14.817020893096924, "response": "def has_balanced_bits(n):\n    s = bin(abs(int(n)))[2:]\n    return s.count('0') == s.count('1')", "error": null, "raw_item": {"task_id": "custom_has_balanced_bits", "prompt": "Write has_balanced_bits(n) that returns True if binary representation of n has equal number of 0s and 1s. Return only the Python function code with no explanations.", "entry_point": "has_balanced_bits", "canonical_solution": "def has_balanced_bits(n: int) -> bool:\n    bits = bin(n)[2:]\n    return bits.count('0') == bits.count('1')", "test": [{"input": [10], "output": true}, {"input": [7], "output": false}, {"input": [9], "output": true}, {"input": [1], "output": false}, {"input": [51], "output": false}, {"input": [56], "output": true}, {"input": [57], "output": false}, {"input": [2], "output": true}, {"input": [15], "output": false}]}}
{"timestamp_utc": "2025-09-24T15:59:32.529217", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 7, "question": "Write remove_repeating_groups(s, k) that repeatedly removes groups of k identical adjacent characters until no more can be removed. Use stack approach. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 10.297547101974487, "response": "def remove_repeating_groups(s, k):\n    if k <= 1:\n        return \"\"\n    stack = []  # each element is [char, count]\n    for ch in s:\n        if stack and stack[-1][0] == ch:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([ch, 1])\n    return ''.join(ch * cnt for ch, cnt in stack)", "error": null, "raw_item": {"task_id": "custom_remove_repeating_groups", "prompt": "Write remove_repeating_groups(s, k) that repeatedly removes groups of k identical adjacent characters until no more can be removed. Use stack approach. Return only the Python function code with no explanations.", "entry_point": "remove_repeating_groups", "canonical_solution": "def remove_repeating_groups(s: str, k: int) -> str:\n    stack = []\n    for char in s:\n        if stack and stack[-1][0] == char:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([char, 1])\n    return ''.join(char * count for char, count in stack)", "test": [{"input": ["deeedbbcccbdaa", 3], "output": "aa"}, {"input": ["pbbcggttciiippooaais", 2], "output": "ps"}, {"input": ["abcd", 2], "output": "abcd"}, {"input": ["aaa", 3], "output": ""}, {"input": ["aaaabbbbaaaa", 4], "output": ""}, {"input": ["aabbcc", 2], "output": ""}, {"input": ["aabbccddeeedcba", 3], "output": "abc"}, {"input": ["", 3], "output": ""}]}}
{"timestamp_utc": "2025-09-24T15:59:47.986610", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 8, "question": "Write resolve_dependencies(deps) that returns valid module load order from dependency dict. Return None if cycle exists. Use DFS topological sort. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 14.454870223999023, "response": "def resolve_dependencies(deps):\n    visited = {}  # 0: unvisited (absent), 1: visiting, 2: visited\n    order = []\n\n    def dfs(node):\n        state = visited.get(node, 0)\n        if state == 1:\n            return False  # cycle\n        if state == 2:\n            return True\n        visited[node] = 1\n        for neigh in deps.get(node, []):\n            if not dfs(neigh):\n                return False\n        visited[node] = 2\n        order.append(node)\n        return True\n\n    nodes = set(deps.keys())\n    for v in deps.values():\n        for n in v:\n            nodes.add(n)\n\n    for n in nodes:\n        if visited.get(n, 0) == 0:\n            if not dfs(n):\n                return None\n    order.reverse()\n    return order", "error": null, "raw_item": {"task_id": "custom_resolve_dependencies", "prompt": "Write resolve_dependencies(deps) that returns valid module load order from dependency dict. Return None if cycle exists. Use DFS topological sort. Return only the Python function code with no explanations.", "entry_point": "resolve_dependencies", "canonical_solution": "def resolve_dependencies(deps: dict[str, list[str]]) -> list[str] | None:\n    visited = {}\n    result = []\n\n    def dfs(node):\n        if node in visited:\n            return visited[node]  # False if cycle\n        visited[node] = False  # mark as visiting\n        for neighbor in deps.get(node, []):\n            res = dfs(neighbor)\n            if res is False:\n                return False\n        visited[node] = True  # mark as visited\n        result.append(node)\n        return True\n\n    for node in deps:\n        if node not in visited:\n            if dfs(node) is False:\n                return None\n    return result[::-1]", "test": [{"input": [{"a": ["b", "c"], "b": ["c"], "c": []}], "output": ["c", "b", "a"]}, {"input": [{"x": ["y"], "y": ["z"], "z": ["x"]}], "output": null}, {"input": [{"m": ["n"], "n": [], "o": []}], "output": ["n", "m", "o"]}, {"input": [{"a": []}], "output": ["a"]}, {"input": [{}], "output": []}]}}
{"timestamp_utc": "2025-09-24T16:00:09.304956", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 9, "question": "Write clean_and_validate_urls(urls) that returns sorted list of unique valid URLs. Valid URLs start with 'http://' or 'https://' (case-insensitive) and contain no spaces. Strip whitespace and remove duplicates. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 20.31612801551819, "response": "def clean_and_validate_urls(urls):\n    seen = set()\n    valid = []\n    for u in urls:\n        s = (u or \"\").strip()\n        if not s:\n            continue\n        if \" \" in s:\n            continue\n        low = s.lower()\n        if low.startswith(\"http://\") or low.startswith(\"https://\"):\n            if s not in seen:\n                seen.add(s)\n                valid.append(s)\n    return sorted(valid)", "error": null, "raw_item": {"task_id": "custom_clean_and_validate_urls", "prompt": "Write clean_and_validate_urls(urls) that returns sorted list of unique valid URLs. Valid URLs start with 'http://' or 'https://' (case-insensitive) and contain no spaces. Strip whitespace and remove duplicates. Return only the Python function code with no explanations.", "entry_point": "clean_and_validate_urls", "canonical_solution": "def clean_and_validate_urls(urls: list[str]) -> list[str]:\n    valid = set()\n    for url in urls:\n        cleaned = url.strip()\n        if cleaned.lower().startswith(\"http://\") or cleaned.lower().startswith(\"https://\"):\n            if \" \" not in cleaned:\n                valid.add(cleaned)\n    return sorted(valid)", "test": [{"input": [[" http://example.com ", "https://valid.site", "ftp://notvalid", "invalid.com", "https://valid.site"]], "output": ["http://example.com", "https://valid.site"]}, {"input": [[]], "output": []}, {"input": [["   https://a.com  ", "http://b.com", "http://b.com  "]], "output": ["http://b.com", "https://a.com"]}, {"input": [["https://with space.com", "http://ok.com"]], "output": ["http://ok.com"]}, {"input": [["HTTP://UPPERCASE.com"]], "output": ["HTTP://UPPERCASE.com"]}]}}
{"timestamp_utc": "2025-09-24T16:00:25.288926", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 10, "question": "Write normalize_filename(filename) that normalizes filenames by converting to lowercase, keeping only a-z, 0-9, underscore, and dots, removing other characters. Return 'unnamed' if result is empty. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 14.982177972793579, "response": "def normalize_filename(filename):\n    import re\n    s = filename.lower()\n    s = re.sub(r'[^a-z0-9._]', '', s)\n    return s or 'unnamed'", "error": null, "raw_item": {"task_id": "custom_normalize_filename", "prompt": "Write normalize_filename(filename) that normalizes filenames by converting to lowercase, keeping only a-z, 0-9, underscore, and dots, removing other characters. Return 'unnamed' if result is empty. Return only the Python function code with no explanations.", "entry_point": "normalize_filename", "canonical_solution": "def normalize_filename(filename: str) -> str:\n    allowed = set(\"abcdefghijklmnopqrstuvwxyz0123456789_.\")\n    result = ''.join(c.lower() for c in filename if c.lower() in allowed)\n    return result if result else \"unnamed\"", "test": [{"input": ["My Report (Final).PDF"], "output": "myreport.final.pdf"}, {"input": ["Résumé_2023!.docx"], "output": "rsum_2023.docx"}, {"input": ["  "], "output": "unnamed"}, {"input": ["file@#name!.TXT"], "output": "filename.txt"}, {"input": ["___"], "output": "___"}, {"input": ["###"], "output": "unnamed"}, {"input": ["ABC123_456.xyz"], "output": "abc123_456.xyz"}]}}
{"timestamp_utc": "2025-09-24T16:00:36.628568", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 11, "question": "Write rank_projects_by_score(projects) that ranks projects by score formula: (stars * 2) + forks - (issues * 3). Return project names sorted by score descending, then alphabetically. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 10.337619066238403, "response": "def rank_projects_by_score(projects):\n    def score(p):\n        return p.get(\"stars\", 0) * 2 + p.get(\"forks\", 0) - p.get(\"issues\", 0) * 3\n    return [p[\"name\"] for p in sorted(projects, key=lambda p: (-score(p), p.get(\"name\", \"\").lower()))]", "error": null, "raw_item": {"task_id": "custom_rank_projects_by_score", "prompt": "Write rank_projects_by_score(projects) that ranks projects by score formula: (stars * 2) + forks - (issues * 3). Return project names sorted by score descending, then alphabetically. Return only the Python function code with no explanations.", "entry_point": "rank_projects_by_score", "canonical_solution": "def rank_projects_by_score(projects: list[tuple[str, int, int, int]]) -> list[str]:\n    def score(proj):\n        return (proj[1] * 2) + proj[2] - (proj[3] * 3)\n    return [p[0] for p in sorted(projects, key=lambda p: (-score(p), p[0]))]", "test": [{"input": [[["ProjectA", 100, 50, 10], ["ProjectB", 80, 70, 5], ["ProjectC", 100, 50, 10]]], "output": ["ProjectA", "ProjectC", "ProjectB"]}, {"input": [[["Alpha", 10, 5, 0], ["Beta", 10, 5, 0]]], "output": ["Alpha", "Beta"]}, {"input": [[["AppX", 0, 0, 0], ["AppY", 0, 0, 1]]], "output": ["AppX", "AppY"]}, {"input": [[]], "output": []}, {"input": [[["ToolZ", 5, 5, 10], ["ToolY", 4, 4, 1]]], "output": ["ToolY", "ToolZ"]}]}}
{"timestamp_utc": "2025-09-24T16:00:54.773811", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 12, "question": "Write longest_prime_gap(nums) that finds the longest sequence of non-prime numbers between two prime numbers in the list. Return length of longest gap. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 17.143836736679077, "response": "def longest_prime_gap(nums):\n    import math\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n in (2, 3):\n            return True\n        if n % 2 == 0:\n            return False\n        r = math.isqrt(n)\n        i = 3\n        while i <= r:\n            if n % i == 0:\n                return False\n            i += 2\n        return True\n\n    found = False\n    current = 0\n    best = 0\n    for x in nums:\n        if is_prime(x):\n            if found and current > best:\n                best = current\n            found = True\n            current = 0\n        else:\n            if found:\n                current += 1\n    return best", "error": null, "raw_item": {"task_id": "custom_longest_prime_gap", "prompt": "Write longest_prime_gap(nums) that finds the longest sequence of non-prime numbers between two prime numbers in the list. Return length of longest gap. Return only the Python function code with no explanations.", "entry_point": "longest_prime_gap", "canonical_solution": "def longest_prime_gap(nums: list[int]) -> int:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                return False\n        return True\n\n    indices = [i for i, val in enumerate(nums) if is_prime(val)]\n    if len(indices) < 2:\n        return 0\n\n    max_gap = 0\n    for i in range(len(indices) - 1):\n        start = indices[i]\n        end = indices[i + 1]\n        gap = end - start - 1\n        max_gap = max(max_gap, gap)\n    return max_gap", "test": [{"input": [[4, 6, 7, 8, 9, 10, 11, 4, 6, 13]], "output": 3}, {"input": [[2, 4, 6, 8, 10, 3]], "output": 4}, {"input": [[4, 6, 8, 10]], "output": 0}, {"input": [[3, 4, 5, 6, 7]], "output": 1}, {"input": [[2, 3]], "output": 0}, {"input": [[17, 4, 6, 9, 15, 19, 21, 23]], "output": 4}, {"input": [[7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]], "output": 4}]}}
{"timestamp_utc": "2025-09-24T16:01:30.586540", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 13, "question": "Write categorize_commit_message(message) that categorizes commit messages. Return 'feature' for add/implement/feature/new, 'fix' for fix/bug/error/resolve, 'refactor' for refactor/cleanup/restructure, 'docs' for docs/documentation/readme, else 'other'. Case-insensitive. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 34.810396909713745, "response": "import re\n\ndef categorize_commit_message(message):\n    s = message if isinstance(message, str) else (\"\" if message is None else str(message))\n    s = s.lower()\n    patterns = {\n        'feature': r'\\b(?:add(?:ed|s|ing)?|implement(?:ed|s|ing)?|feature|new)\\b',\n        'fix': r'\\b(?:fix(?:ed|es|ing)?|bug(?:s)?|error(?:s)?|resolve(?:d|s|ing)?)\\b',\n        'refactor': r'\\b(?:refactor(?:ed|s|ing)?|cleanup(?:s|ed)?|restructure(?:d|s|ing)?)\\b',\n        'docs': r'\\b(?:docs?|documentation|readme)\\b',\n    }\n    for category, pattern in patterns.items():\n        if re.search(pattern, s):\n            return category\n    return 'other'", "error": null, "raw_item": {"task_id": "custom_categorize_commit_message", "prompt": "Write categorize_commit_message(message) that categorizes commit messages. Return 'feature' for add/implement/feature/new, 'fix' for fix/bug/error/resolve, 'refactor' for refactor/cleanup/restructure, 'docs' for docs/documentation/readme, else 'other'. Case-insensitive. Return only the Python function code with no explanations.", "entry_point": "categorize_commit_message", "canonical_solution": "def categorize_commit_message(message: str) -> str:\n    msg = message.lower()\n    categories = {\n        \"feature\": [\"add\", \"implement\", \"feature\", \"new\"],\n        \"fix\": [\"fix\", \"bug\", \"error\", \"resolve\"],\n        \"refactor\": [\"refactor\", \"cleanup\", \"restructure\"],\n        \"docs\": [\"docs\", \"documentation\", \"readme\"],\n    }\n    for label, keywords in categories.items():\n        if any(kw in msg for kw in keywords):\n            return label\n    return \"other\"", "test": [{"input": ["Fix bug in user login"], "output": "fix"}, {"input": ["Refactor payment module"], "output": "refactor"}, {"input": ["Updated README and docs"], "output": "docs"}, {"input": ["Initial commit"], "output": "other"}, {"input": ["Implemented new feature for signup"], "output": "feature"}, {"input": ["cleanup redundant logic"], "output": "refactor"}, {"input": ["Error handling for empty input"], "output": "fix"}, {"input": ["add configuration support"], "output": "feature"}, {"input": ["Documentation improvements"], "output": "docs"}, {"input": ["Minor UI tweaks"], "output": "other"}]}}
{"timestamp_utc": "2025-09-24T16:02:08.320871", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 14, "question": "Write max_repeated_substring(s) that returns length of longest non-overlapping repeated substring. Use sliding window with seen set. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 36.73128604888916, "response": "def max_repeated_substring(s):\n    n = len(s)\n    if n < 2:\n        return 0\n    for L in range(n // 2, 0, -1):\n        seen = {}\n        for i in range(n - L + 1):\n            sub = s[i:i+L]\n            if sub in seen:\n                if i - seen[sub] >= L:\n                    return L\n            else:\n                seen[sub] = i\n    return 0", "error": null, "raw_item": {"task_id": "custom_max_repeated_substring", "prompt": "Write max_repeated_substring(s) that returns length of longest non-overlapping repeated substring. Use sliding window with seen set. Return only the Python function code with no explanations.", "entry_point": "max_repeated_substring", "canonical_solution": "def max_repeated_substring(s: str) -> int:\n    n = len(s)\n    max_len = 0\n    for l in range(1, n // 2 + 1):\n        seen = set()\n        i = 0\n        while i + l <= n:\n            substr = s[i:i+l]\n            if substr in seen:\n                max_len = max(max_len, l)\n                i += l  # move forward non-overlapping\n            else:\n                seen.add(substr)\n                i += 1\n    return max_len", "test": [{"input": ["abababc"], "output": 2}, {"input": ["aaaa"], "output": 2}, {"input": ["abcabcabc"], "output": 3}, {"input": ["abcdef"], "output": 0}, {"input": ["ababa"], "output": 1}, {"input": [""], "output": 0}, {"input": ["a"], "output": 0}, {"input": ["abcdabcd"], "output": 4}, {"input": ["xyzxyzabcabc"], "output": 3}, {"input": ["abababab"], "output": 2}]}}
{"timestamp_utc": "2025-09-24T16:02:25.463164", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 15, "question": "Write longest_valid_bracket_substring(s) that returns length of longest valid parentheses substring. Use stack with indices. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 16.1417179107666, "response": "def longest_valid_bracket_substring(s):\n    stack = [-1]\n    maxlen = 0\n    for i, ch in enumerate(s):\n        if ch == '(':\n            stack.append(i)\n        else:  # assume ch == ')'\n            stack.pop()\n            if not stack:\n                stack.append(i)\n            else:\n                maxlen = max(maxlen, i - stack[-1])\n    return maxlen", "error": null, "raw_item": {"task_id": "custom_longest_valid_bracket_substring", "prompt": "Write longest_valid_bracket_substring(s) that returns length of longest valid parentheses substring. Use stack with indices. Return only the Python function code with no explanations.", "entry_point": "longest_valid_bracket_substring", "canonical_solution": "def longest_valid_bracket_substring(s: str) -> int:\n    stack = [-1]\n    max_len = 0\n\n    for i, ch in enumerate(s):\n        if ch == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if not stack:\n                stack.append(i)\n            else:\n                max_len = max(max_len, i - stack[-1])\n\n    return max_len", "test": [{"input": ["(()"], "output": 2}, {"input": [")()())"], "output": 4}, {"input": [""], "output": 0}, {"input": ["((("], "output": 0}, {"input": ["()(()))())"], "output": 6}, {"input": ["((()))"], "output": 6}, {"input": ["()()()"], "output": 6}, {"input": [")((()))("], "output": 6}, {"input": ["(()(((()"], "output": 2}, {"input": ["())(())"], "output": 4}]}}
{"timestamp_utc": "2025-09-24T16:02:43.661582", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 16, "question": "Write summarize_category_totals(purchases) that returns list of [category, total] pairs sorted alphabetically by category. Sum amounts by category. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 17.196188926696777, "response": "def summarize_category_totals(purchases):\n    totals = {}\n    for p in purchases:\n        if isinstance(p, dict):\n            cat = p.get('category')\n            amt = p.get('amount', 0)\n        else:\n            try:\n                cat, amt = p[0], p[1]\n            except Exception:\n                continue\n        if cat is None:\n            continue\n        try:\n            val = amt if isinstance(amt, (int, float)) else float(amt)\n        except Exception:\n            continue\n        totals[cat] = totals.get(cat, 0) + val\n    return [[cat, totals[cat]] for cat in sorted(totals, key=lambda c: str(c))]", "error": null, "raw_item": {"task_id": "custom_summarize_category_totals", "prompt": "Write summarize_category_totals(purchases) that returns list of [category, total] pairs sorted alphabetically by category. Sum amounts by category. Return only the Python function code with no explanations.", "entry_point": "summarize_category_totals", "canonical_solution": "def summarize_category_totals(purchases: list[dict]) -> list[list]:\n    totals = {}\n    for item in purchases:\n        cat = item[\"category\"]\n        amt = item[\"amount\"]\n        totals[cat] = totals.get(cat, 0.0) + amt\n    return sorted([[cat, total] for cat, total in totals.items()])", "test": [{"input": [[{"category": "groceries", "amount": 25.5}, {"category": "electronics", "amount": 99.99}, {"category": "groceries", "amount": 13.0}, {"category": "books", "amount": 10.0}]], "output": [["books", 10.0], ["electronics", 99.99], ["groceries", 38.5]]}, {"input": [[{"category": "a", "amount": 1.0}, {"category": "b", "amount": 2.0}, {"category": "a", "amount": 3.0}, {"category": "c", "amount": 4.0}]], "output": [["a", 4.0], ["b", 2.0], ["c", 4.0]]}, {"input": [[]], "output": []}, {"input": [[{"category": "x", "amount": 0.0}, {"category": "x", "amount": 0.0}]], "output": [["x", 0.0]]}, {"input": [[{"category": "Z", "amount": 2.0}, {"category": "a", "amount": 1.0}]], "output": [["Z", 2.0], ["a", 1.0]]}]}}
{"timestamp_utc": "2025-09-24T16:02:51.732805", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 17, "question": "Write filter_unique_keywords(keywords, banned) that returns sorted unique keywords (lowercased) excluding banned words. Case-insensitive comparison. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 7.06902289390564, "response": "def filter_unique_keywords(keywords, banned):\n    banned_set = {w.lower() for w in banned}\n    return sorted({kw.lower() for kw in keywords if kw.lower() not in banned_set})", "error": null, "raw_item": {"task_id": "custom_filter_unique_keywords", "prompt": "Write filter_unique_keywords(keywords, banned) that returns sorted unique keywords (lowercased) excluding banned words. Case-insensitive comparison. Return only the Python function code with no explanations.", "entry_point": "filter_unique_keywords", "canonical_solution": "def filter_unique_keywords(keywords: list[str], banned: list[str]) -> list[str]:\n    banned_set = set(word.lower() for word in banned)\n    unique = set()\n\n    for word in keywords:\n        w = word.lower()\n        if w not in banned_set:\n            unique.add(w)\n\n    return sorted(unique)", "test": [{"input": [["Python", "code", "AI", "python", "Data", "Code"], ["ai"]], "output": ["code", "data", "python"]}, {"input": [[], ["test"]], "output": []}, {"input": [["ML", "AI", "ml", "AI"], ["ai"]], "output": ["ml"]}, {"input": [["hello", "world", "HELLO", "WORLD"], []], "output": ["hello", "world"]}, {"input": [["Data", "Science", "AI"], ["science", "ai"]], "output": ["data"]}, {"input": [["Python", "PYTHON", "python"], ["PYTHON"]], "output": []}]}}
{"timestamp_utc": "2025-09-24T16:03:02.617010", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 18, "question": "Write next_greater_circular(nums) that returns list where each position contains next greater element circularly. Use monotonic stack. O(n) time. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 9.881096124649048, "response": "def next_greater_circular(nums):\n    n = len(nums)\n    if n == 0:\n        return []\n    ans = [-1] * n\n    stack = []\n    for i in range(2 * n):\n        val = nums[i % n]\n        while stack and nums[stack[-1]] < val:\n            ans[stack.pop()] = val\n        if i < n:\n            stack.append(i)\n    return ans", "error": null, "raw_item": {"task_id": "ds_next_greater_circular", "prompt": "Write next_greater_circular(nums) that returns list where each position contains next greater element circularly. Use monotonic stack. O(n) time. Return only the Python function code with no explanations.", "entry_point": "next_greater_circular", "canonical_solution": "def next_greater_circular(nums):\n    n = len(nums)\n    res = [-1]*n\n    stack = []  # indices with decreasing stack by value\n    for i in range(2*n):\n        x = nums[i % n]\n        while stack and nums[stack[-1]] < x:\n            idx = stack.pop()\n            res[idx] = x\n        if i < n:\n            stack.append(i)\n    return res\n", "test": [{"input": [[1, 2, 1]], "output": [2, -1, 2]}, {"input": [[3, 8, 4, 1, 2]], "output": [8, -1, 8, 2, 3]}, {"input": [[5, 4, 3, 2, 1]], "output": [-1, 5, 5, 5, 5]}, {"input": [[2, 2, 2]], "output": [-1, -1, -1]}, {"input": [[]], "output": []}]}}
{"timestamp_utc": "2025-09-24T16:03:19.000888", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 19, "question": "Write normalize_product_code(s) that keeps only alphanumerics and dashes, converts to uppercase, collapses multiple dashes, trims leading/trailing dashes. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 15.38144588470459, "response": "def normalize_product_code(s):\n    import re\n    if s is None:\n        return ''\n    s = str(s).upper()\n    s = re.sub(r'[^A-Z0-9-]+', '', s)\n    s = re.sub(r'-{2,}', '-', s)\n    return s.strip('-')", "error": null, "raw_item": {"task_id": "str_normalize_product_code", "prompt": "Write normalize_product_code(s) that keeps only alphanumerics and dashes, converts to uppercase, collapses multiple dashes, trims leading/trailing dashes. Return only the Python function code with no explanations.", "entry_point": "normalize_product_code", "canonical_solution": "import re\ndef normalize_product_code(s):\n    # keep alnum and dash\n    s = ''.join(ch for ch in s if ch.isalnum() or ch=='-')\n    s = s.upper()\n    s = re.sub(r'-{2,}', '-', s)\n    s = s.strip('-')\n    return s\n", "test": [{"input": [" abC--12__-xx "], "output": "ABC-12-XX"}, {"input": ["---a---b---"], "output": "A-B"}, {"input": ["***"], "output": ""}, {"input": ["proD-uct_99!!"], "output": "PROD-UCT99"}, {"input": [""], "output": ""}]}}
{"timestamp_utc": "2025-09-24T16:03:33.543085", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 20, "question": "Write single_number_triplicates(nums) that finds element appearing once while others appear thrice. Use bitwise counting without hash maps. O(n) time, O(1) space. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 13.539084911346436, "response": "def single_number_triplicates(nums):\n    result = 0\n    for i in range(32):\n        bit_sum = 0\n        for num in nums:\n            bit_sum += (num >> i) & 1\n        if bit_sum % 3:\n            result |= (1 << i)\n    if result >= 1 << 31:\n        result -= 1 << 32\n    return result", "error": null, "raw_item": {"task_id": "bit_single_number_triplicates", "prompt": "Write single_number_triplicates(nums) that finds element appearing once while others appear thrice. Use bitwise counting without hash maps. O(n) time, O(1) space. Return only the Python function code with no explanations.", "entry_point": "single_number_triplicates", "canonical_solution": "def single_number_triplicates(nums):\n    ones = 0\n    twos = 0\n    for x in nums:\n        ones = (ones ^ x) & ~twos\n        twos = (twos ^ x) & ~ones\n    return ones\n", "test": [{"input": [[2, 2, 3, 2]], "output": 3}, {"input": [[0, 1, 0, 1, 0, 1, 99]], "output": 99}, {"input": [[-2, -2, -2, -5]], "output": -5}, {"input": [[7]], "output": 7}, {"input": [[10, 10, 10, -1]], "output": -1}]}}
{"timestamp_utc": "2025-09-24T16:03:50.755389", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 21, "question": "Write can_finish_prereqs(pairs) where pairs are (a,b) meaning 'b precedes a'. Return True if acyclic. Use topological sort without external libraries. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 16.208786964416504, "response": "def can_finish_prereqs(pairs):\n    # pairs: iterable of (a, b) meaning b precedes a (edge b -> a)\n    adj = {}\n    indegree = {}\n    for a, b in pairs:\n        if b not in adj:\n            adj[b] = []\n        adj[b].append(a)\n        if b not in indegree:\n            indegree[b] = 0\n        indegree[a] = indegree.get(a, 0) + 1\n\n    # include isolated nodes (if any appeared only as left elements with no incoming edges handled above)\n    # (already covered by indegree.get when building; if pairs empty, indegree may be empty)\n    queue = [node for node, deg in indegree.items() if deg == 0]\n    visited = 0\n    while queue:\n        node = queue.pop()\n        visited += 1\n        for nei in adj.get(node, ()):\n            indegree[nei] -= 1\n            if indegree[nei] == 0:\n                queue.append(nei)\n    return visited == len(indegree)", "error": null, "raw_item": {"task_id": "graph_can_finish_prereqs", "prompt": "Write can_finish_prereqs(pairs) where pairs are (a,b) meaning 'b precedes a'. Return True if acyclic. Use topological sort without external libraries. Return only the Python function code with no explanations.", "entry_point": "can_finish_prereqs", "canonical_solution": "from collections import defaultdict, deque\ndef can_finish_prereqs(pairs):\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    nodes = set()\n    for a,b in pairs:\n        adj[b].append(a)\n        indeg[a] += 1\n        nodes.add(a); nodes.add(b)\n        if b not in indeg: indeg[b] = indeg.get(b,0)\n    q = deque([v for v in nodes if indeg.get(v,0)==0])\n    visited = 0\n    while q:\n        v = q.popleft()\n        visited += 1\n        for w in adj[v]:\n            indeg[w] -= 1\n            if indeg[w]==0:\n                q.append(w)\n    return visited == len(nodes)\n", "test": [{"input": [[["C2", "C1"], ["C3", "C2"]]], "output": true}, {"input": [[["A", "B"], ["B", "C"], ["C", "A"]]], "output": false}, {"input": [[["A", "B"]]], "output": true}, {"input": [[["X", "Y"], ["Y", "Z"], ["Z", "X"]]], "output": false}, {"input": [[[]]], "output": true}]}}
{"timestamp_utc": "2025-09-24T16:04:32.627557", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 22, "question": "Write safe_deep_get(obj, path, default=None) that safely traverses nested dicts/lists/tuples using path keys/indices. Return default if any access fails. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 40.8692901134491, "response": "def safe_deep_get(obj, path, default=None):\n    \"\"\"\n    Safely traverse nested dicts/lists/tuples using an iterable of keys/indices.\n    If any access fails, returns `default`.\n    Treats a non-list/tuple `path` (including strings) as a single key.\n    \"\"\"\n    if path is None:\n        return obj\n    # treat strings/bytes and non-list/tuple as a single key\n    if not isinstance(path, (list, tuple)):\n        path_iter = (path,)\n    else:\n        path_iter = path\n\n    cur = obj\n    for key in path_iter:\n        if cur is None:\n            return default\n        # dict-like access\n        if isinstance(cur, dict):\n            if key in cur:\n                cur = cur[key]\n            else:\n                return default\n        # list/tuple access by integer index or slice\n        elif isinstance(cur, (list, tuple)):\n            # allow slice objects directly\n            if isinstance(key, slice):\n                try:\n                    cur = cur[key]\n                except Exception:\n                    return default\n            else:\n                # require integer index (allow things convertible to int like numpy ints or numeric strings)\n                try:\n                    idx = int(key)\n                except Exception:\n                    return default\n                try:\n                    cur = cur[idx]\n                except Exception:\n                    return default\n        else:\n            return default\n    return cur", "error": null, "raw_item": {"task_id": "se_safe_deep_get", "entry_point": "safe_deep_get", "prompt": "Write safe_deep_get(obj, path, default=None) that safely traverses nested dicts/lists/tuples using path keys/indices. Return default if any access fails. Return only the Python function code with no explanations.", "canonical_solution": "def safe_deep_get(obj, path, default=None):\n    cur = obj\n    for key in path:\n        if isinstance(cur, dict):\n            if key in cur:\n                cur = cur[key]\n            else:\n                return default\n        elif isinstance(cur, (list, tuple)):\n            if isinstance(key, int) and -len(cur) <= key < len(cur):\n                cur = cur[key]\n            else:\n                return default\n        else:\n            return default\n    return cur\n", "test": [{"input": [{"a": {"b": [10, 20, {"c": 42}]}}, ["a", "b", 2, "c"], null], "output": 42}, {"input": [{"a": [1, 2, 3]}, ["a", 5], "x"], "output": "x"}, {"input": [{"x": 0}, ["y"], 99], "output": 99}, {"input": [[1, 2, 3], [0], null], "output": 1}, {"input": [[1, 2, 3], ["0"], "err"], "output": "err"}]}}
{"timestamp_utc": "2025-09-24T16:04:53.103295", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 23, "question": "Write clean_and_split_sentences(text) that removes non-alphanumeric chars except .!?, normalizes whitespace, splits on sentence delimiters, returns cleaned sentence list. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 19.472676277160645, "response": "def clean_and_split_sentences(text):\n    import re\n    if not isinstance(text, str):\n        text = str(text)\n    # Remove characters that are not alphanumeric, whitespace, or .!? \n    cleaned = re.sub(r'[^A-Za-z0-9\\s\\.!\\?]+', '', text)\n    # Normalize whitespace\n    cleaned = re.sub(r'\\s+', ' ', cleaned).strip()\n    # Split on one or more sentence delimiters (., !, ?)\n    parts = re.split(r'[\\.!\\?]+', cleaned)\n    # Trim and filter out empty segments\n    return [p.strip() for p in parts if p.strip()]", "error": null, "raw_item": {"task_id": "str_clean_and_split_sentences", "entry_point": "clean_and_split_sentences", "prompt": "Write clean_and_split_sentences(text) that removes non-alphanumeric chars except .!?, normalizes whitespace, splits on sentence delimiters, returns cleaned sentence list. Return only the Python function code with no explanations.", "canonical_solution": "import re\n\ndef clean_and_split_sentences(text):\n    # Keep only letters, digits, punctuation .,!,?\n    text = re.sub(r\"[^A-Za-z0-9.!?\\s]\", \"\", text)\n    # Normalize whitespace\n    text = re.sub(r\"\\s+\", \" \", text).strip()\n    # Split on sentence delimiters\n    parts = re.split(r\"[.!?]\", text)\n    # Clean and filter\n    result = [p.strip() for p in parts if p.strip()]\n    return result\n", "test": [{"input": ["Hello!!   How are---you???   Fine."], "output": ["Hello", "How areyou", "Fine"]}, {"input": ["  multiple   spaces   and ###symbols!!"], "output": ["multiple spaces and symbols"]}, {"input": ["Nothing to clean"], "output": ["Nothing to clean"]}, {"input": ["???"], "output": []}]}}
{"timestamp_utc": "2025-09-24T16:05:02.833102", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 24, "question": "Write count_set_bits(n) that counts 1-bits in binary representation using efficient bit manipulation (Brian Kernighan's algorithm). Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 8.72784423828125, "response": "def count_set_bits(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count", "error": null, "raw_item": {"task_id": "bit_counting_set_bits", "entry_point": "count_set_bits", "prompt": "Write count_set_bits(n) that counts 1-bits in binary representation using efficient bit manipulation (Brian Kernighan's algorithm). Return only the Python function code with no explanations.", "canonical_solution": "def count_set_bits(n):\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    count = 0\n    while n:\n        n &= n - 1  # Clear the least significant bit set\n        count += 1\n    return count\n", "test": [{"input": [11], "output": 3}, {"input": [0], "output": 0}, {"input": [255], "output": 8}, {"input": [1023], "output": 10}, {"input": [1], "output": 1}]}}
{"timestamp_utc": "2025-09-24T16:06:12.259904", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 25, "question": "Write filter_map_validate(records) that normalizes, validates, and filters product records, returning sorted list of valid IDs. Complex multi-step validation with price parsing, type constraints, and conditional rules. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 68.42346382141113, "response": "def filter_map_validate(records):\n    from decimal import Decimal, InvalidOperation, ROUND_HALF_UP\n    import re\n\n    # Allowed normalized keys mapping\n    KEY_ALIASES = {\n        'id': {'id', 'product_id', 'sku', 'productid'},\n        'name': {'name', 'title'},\n        'price': {'price', 'cost', 'amount'},\n        'type': {'type', 'category', 'kind'},\n        'quantity': {'quantity', 'qty', 'stock'},\n        'active': {'active', 'enabled', 'is_active'},\n        'components': {'components', 'parts', 'items'}\n    }\n    # reverse lookup: map any alias to canonical name\n    ALIAS_TO_KEY = {}\n    for k, aliases in KEY_ALIASES.items():\n        for a in aliases:\n            ALIAS_TO_KEY[a.lower()] = k\n\n    ALLOWED_TYPES = {'physical', 'digital', 'service', 'bundle'}\n\n    TRUTHY = {'1', 'true', 'yes', 'y', 't'}\n    FALSY = {'0', 'false', 'no', 'n', 'f'}\n\n    def normalize_record(rec):\n        if not isinstance(rec, dict):\n            return None\n        out = {}\n        for raw_k, v in rec.items():\n            if not isinstance(raw_k, str):\n                k = str(raw_k).lower().strip()\n            else:\n                k = raw_k.lower().strip()\n            canonical = ALIAS_TO_KEY.get(k, k)  # unknown keys kept as-is\n            out[canonical] = v\n        # also lower/strip string values for some fields handled later\n        return out\n\n    def parse_bool(val):\n        if val is None:\n            return True\n        if isinstance(val, bool):\n            return val\n        s = str(val).strip().lower()\n        if s == '':\n            return True\n        if s in TRUTHY:\n            return True\n        if s in FALSY:\n            return False\n        # fallback: truthy for non-empty strings except explicit falsy\n        if s:\n            return True\n        return False\n\n    def parse_id(val):\n        if val is None:\n            raise ValueError(\"missing id\")\n        if isinstance(val, int):\n            if val <= 0:\n                raise ValueError(\"id<=0\")\n            return val\n        s = str(val).strip()\n        if s == '':\n            raise ValueError(\"empty id\")\n        # allow numeric strings, possibly float-looking but must represent integer\n        if re.fullmatch(r'[+-]?\\d+', s):\n            iv = int(s)\n            if iv <= 0:\n                raise ValueError(\"id<=0\")\n            return iv\n        # try float -> int if exact\n        try:\n            if re.fullmatch(r'[+-]?\\d+\\.\\d+', s):\n                f = float(s)\n                if f.is_integer():\n                    iv = int(f)\n                    if iv <= 0:\n                        raise ValueError(\"id<=0\")\n                    return iv\n        except Exception:\n            pass\n        raise ValueError(\"invalid id\")\n\n    def parse_name(val):\n        if val is None:\n            raise ValueError(\"missing name\")\n        s = str(val).strip()\n        if not s:\n            raise ValueError(\"empty name\")\n        if len(s) > 100:\n            raise ValueError(\"name too long\")\n        # must contain at least one alphanumeric character\n        if not re.search(r'\\w', s):\n            raise ValueError(\"name no alnum\")\n        # no control characters\n        if re.search(r'[\\x00-\\x1f\\x7f]', s):\n            raise ValueError(\"name has control chars\")\n        return s\n\n    def parse_type(val):\n        if val is None:\n            raise ValueError(\"missing type\")\n        s = str(val).strip().lower()\n        if s == '':\n            raise ValueError(\"empty type\")\n        if s not in ALLOWED_TYPES:\n            raise ValueError(\"unknown type\")\n        return s\n\n    def parse_price(val):\n        if val is None:\n            raise ValueError(\"missing price\")\n        if isinstance(val, Decimal):\n            d = val\n        elif isinstance(val, (int,)):\n            d = Decimal(val)\n        elif isinstance(val, float):\n            # convert float via str to avoid binary issues\n            d = Decimal(str(val))\n        else:\n            s = str(val).strip()\n            if s == '':\n                raise ValueError(\"empty price\")\n            ls = s.lower().strip()\n            if ls in {'free', 'gratis', '0', 'zero', 'na', 'n/a'}:\n                d = Decimal('0')\n            else:\n                # remove currency symbols and surrounding text but keep digits, commas, dots, minus\n                # handle parentheses negative notation\n                s2 = s.strip()\n                neg = False\n                if s2.startswith('(') and s2.endswith(')'):\n                    neg = True\n                    s2 = s2[1:-1]\n                # remove letters and currency symbols but keep digits, comma, dot, minus\n                s_clean = re.sub(r'[^\\d,.\\-]', '', s2)\n                # if multiple minus signs or misplaced minus -> invalid\n                if s_clean.count('-') > 1:\n                    raise ValueError(\"bad price\")\n                if '-' in s_clean and not s_clean.startswith('-'):\n                    # stray minus -> invalid\n                    raise ValueError(\"bad price\")\n                if neg:\n                    s_clean = '-' + s_clean.lstrip('-')\n                # Decide decimal separator\n                comma_count = s_clean.count(',')\n                dot_count = s_clean.count('.')\n                if comma_count and dot_count:\n                    # whichever appears last is decimal separator\n                    if s_clean.rfind('.') > s_clean.rfind(','):\n                        # dot decimal, remove commas\n                        s_norm = s_clean.replace(',', '')\n                    else:\n                        # comma decimal, remove dots and replace comma with dot\n                        s_norm = s_clean.replace('.', '').replace(',', '.')\n                elif comma_count and not dot_count:\n                    # if last comma is within last 3 chars -> decimal separator, else remove commas\n                    last_comma_pos = s_clean.rfind(',')\n                    if len(s_clean) - last_comma_pos - 1 in (1, 2):  # decimal places 1 or 2\n                        s_norm = s_clean.replace(',', '.')\n                    else:\n                        s_norm = s_clean.replace(',', '')\n                else:\n                    # only dots or neither\n                    s_norm = s_clean\n                # avoid empty\n                if not re.search(r'\\d', s_norm):\n                    raise ValueError(\"no digits in price\")\n                try:\n                    d = Decimal(s_norm)\n                except InvalidOperation:\n                    raise ValueError(\"bad price format\")\n        # quantize to two decimals\n        try:\n            dq = d.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)\n        except (InvalidOperation, ValueError):\n            raise ValueError(\"bad price value\")\n        if dq < Decimal('0'):\n            raise ValueError(\"negative price\")\n        return dq\n\n    def parse_quantity(val, type_):\n        if val is None:\n            return None\n        if isinstance(val, int):\n            q = val\n        else:\n            s = str(val).strip()\n            if s == '':\n                return None\n            if not re.fullmatch(r'[+-]?\\d+', s):\n                # allow floats that are integer\n                if re.fullmatch(r'[+-]?\\d+\\.\\d+', s):\n                    try:\n                        f = float(s)\n                        if f.is_integer():\n                            q = int(f)\n                        else:\n                            raise ValueError(\"quantity not integer\")\n                    except Exception:\n                        raise ValueError(\"bad quantity\")\n                else:\n                    raise ValueError(\"bad quantity\")\n            else:\n                q = int(s)\n        if q < 0:\n            raise ValueError(\"quantity negative\")\n        # Specific: for digital/service quantity is optional; for physical/bundle quantity should be specified\n        if type_ in {'physical', 'bundle'} and q is None:\n            raise ValueError(\"quantity required for physical/bundle\")\n        return q\n\n    valid_ids = set()\n    seen_ids = set()\n    for rec in records:\n        try:\n            nrec = normalize_record(rec)\n            if nrec is None:\n                continue\n            # parse active\n            active = parse_bool(nrec.get('active', True))\n            if not active:\n                continue\n            # parse id\n            try:\n                pid = parse_id(nrec.get('id'))\n            except ValueError:\n                continue\n            # avoid duplicates: skip subsequent duplicates\n            if pid in seen_ids:\n                continue\n            seen_ids.add(pid)\n            # parse required fields\n            try:\n                name = parse_name(nrec.get('name'))\n                type_ = parse_type(nrec.get('type'))\n                price = parse_price(nrec.get('price'))\n            except ValueError:\n                continue\n            # parse quantity with type-dependent behavior\n            try:\n                qty = parse_quantity(nrec.get('quantity'), type_)\n            except ValueError:\n                continue\n            # conditional rules\n            # - bundle requires components list of >=2 items\n            if type_ == 'bundle':\n                comps = nrec.get('components')\n                if not isinstance(comps, (list, tuple)) or len(comps) < 2:\n                    continue\n                # all components must be non-empty ids (we don't validate existence here)\n                ok_comps = True\n                for c in comps:\n                    try:\n                        # accept numeric-ish component ids\n                        _ = parse_id(c)\n                    except Exception:\n                        ok_comps = False\n                        break\n                if not ok_comps:\n                    continue\n            # - service type should have price >= 0 (already enforced) and may not have physical quantity\n            if type_ == 'service':\n                # if quantity present and greater than 1, treat as invalid (services are per-request)\n                if qty is not None and qty > 1:\n                    continue\n            # - physical items: quantity must be present and >=0 (enforced)\n            if type_ == 'physical':\n                if qty is None:\n                    continue\n            # - digital items: quantity ignored (allowed), price can be zero\n            # - extra sanity: price must be reasonable (not > 10 million)\n            if price > Decimal('10000000'):\n                continue\n            # everything passed\n            valid_ids.add(pid)\n        except Exception:\n            # safeguard: any unexpected error -> skip record\n            continue\n\n    return sorted(valid_ids)", "error": null, "raw_item": {"task_id": "se_filter_map_validate_nested", "entry_point": "filter_map_validate", "prompt": "Write filter_map_validate(records) that normalizes, validates, and filters product records, returning sorted list of valid IDs. Complex multi-step validation with price parsing, type constraints, and conditional rules. Return only the Python function code with no explanations.", "canonical_solution": "import re\n\ntype_order = {\"ent\": 0, \"pro\": 1, \"std\": 2}\n\ndef _parse_price(x):\n    if isinstance(x, (int, float)):\n        return float(x) if x >= 0 else None\n    if not isinstance(x, str):\n        return None\n    s = x.strip()\n    if not s:\n        return None\n    s = re.sub(r\"[\\s$€£¥]\", \"\", s)\n    if \",\" in s and \".\" in s:\n        if s.find(\",\") < s.find(\".\"):\n            s = s.replace(\",\", \"\")\n        else:\n            s = s.replace(\".\", \"\").replace(\",\", \".\")\n    elif \",\" in s:\n        s = s.replace(\",\", \".\")\n    try:\n        v = float(s)\n        return v if v >= 0 else None\n    except Exception:\n        return None\n\ndef _to_int(x):\n    if isinstance(x, bool):\n        return None\n    if isinstance(x, int):\n        return x\n    if isinstance(x, str):\n        s = x.strip()\n        if s and s.lstrip(\"-+\").isdigit():\n            try:\n                return int(s)\n            except Exception:\n                return None\n    return None\n\ndef _to_float(x):\n    if isinstance(x, (int, float)):\n        return float(x)\n    if isinstance(x, str):\n        try:\n            return float(x.strip())\n        except Exception:\n            return None\n    return None\n\ndef _to_pct(x):\n    if x is None:\n        return None\n    if isinstance(x, (int, float)):\n        v = float(x)\n    elif isinstance(x, str):\n        try:\n            v = float(x.strip().strip('%'))\n        except Exception:\n            return None\n    else:\n        return None\n    if v < 0:\n        v = 0.0\n    if v > 100:\n        v = 100.0\n    return v\n\ndef filter_map_validate(records):\n    if not isinstance(records, list):\n        return []\n    kept = []\n    for rec in records:\n        if not isinstance(rec, dict):\n            continue\n        # --- id ---\n        rid = rec.get(\"id\")\n        rid = str(rid).strip() if rid is not None else \"\"\n        if not rid:\n            continue\n        # --- meta ---\n        meta = rec.get(\"meta\") or {}\n        if not isinstance(meta, dict):\n            meta = {}\n        rtype = str(meta.get(\"type\") or \"\").strip().lower()\n        flags = meta.get(\"flags\")\n        if isinstance(flags, list):\n            flags_norm = [str(t).strip().lower() for t in flags if isinstance(t, (str, int, float))]\n        else:\n            flags_norm = []\n        if rtype not in (\"std\",\"pro\",\"ent\"):\n            continue\n        # --- price ---\n        price = _parse_price(rec.get(\"price\"))\n        if price is None:\n            continue\n        # --- attrs ---\n        attrs = rec.get(\"attrs\") or {}\n        if not isinstance(attrs, dict):\n            attrs = {}\n        color = attrs.get(\"color\")\n        color = str(color).strip().lower() if isinstance(color, str) else None\n        size = attrs.get(\"size\")\n        if size is not None:\n            size = _to_int(size)\n        weight = attrs.get(\"weight\")\n        if weight is not None:\n            weight = _to_float(weight)\n        cond = attrs.get(\"condition\")\n        cond = str(cond).strip().upper() if isinstance(cond, str) else None\n        discount = _to_pct(attrs.get(\"discount\"))\n        # --- stock ---\n        stock = _to_int(rec.get(\"stock\"))\n        if stock is None:\n            stock = 0\n        if stock < 0:\n            stock = 0\n        # --- Validation A: color/flag gate ---\n        if not ((color in {\"red\",\"blue\",\"green\"}) or (\"eco\" in flags_norm)):\n            continue\n        # --- Validation B: price caps ---\n        if rtype in (\"std\",\"pro\") and price > 1000:\n            continue\n        if rtype == \"ent\" and price > 5000:\n            continue\n        # --- Validation C: refurb implies good condition ---\n        if \"refurb\" in flags_norm:\n            if cond not in {\"A\",\"B\"}:\n                continue\n        # --- Validation D: ent requires size>=10 and stock>=1 ---\n        if rtype == \"ent\":\n            if size is None or size < 10 or stock < 1:\n                continue\n        # --- Validation E: pro weight <= 50 if provided ---\n        if rtype == \"pro\" and weight is not None and weight > 50.0:\n            continue\n        kept.append({\n            \"id\": rid,\n            \"type\": rtype,\n            \"price\": price\n        })\n    # sort: type order (ent > pro > std) i.e., ent first, then pro, then std\n    kept.sort(key=lambda r: (type_order.get(r[\"type\"], 3), r[\"price\"], r[\"id\"].lower()))\n    return [r[\"id\"] for r in kept]\n", "test": [{"input": [[{"id": " A-1 ", "meta": {"type": "ent", "flags": ["Eco"]}, "price": "€4,999.00", "attrs": {"size": "12", "color": "Green"}, "stock": "5"}, {"id": "B-2", "meta": {"type": "pro", "flags": ["refurb"]}, "price": "$800", "attrs": {"weight": "49.5", "color": "blue", "condition": "B"}, "stock": 0}, {"id": "c-3", "meta": {"type": "std", "flags": []}, "price": "1200", "attrs": {"color": "red"}, "stock": 10}, {"id": "d-4", "meta": {"type": "ent", "flags": ["eco", "refurb"]}, "price": "5100", "attrs": {"size": 15, "color": "green", "condition": "A"}, "stock": 2}, {"id": "e-5", "meta": {"type": "pro", "flags": []}, "price": "999.99", "attrs": {"color": "yellow"}, "stock": 7}]], "output": ["A-1", "B-2"]}, {"input": [[{"id": 101, "meta": {"type": "pro", "flags": ["eco"]}, "price": "1,000.00", "attrs": {"color": "RED", "weight": "50"}, "stock": "-3"}, {"id": 102, "meta": {"type": "pro", "flags": ["eco"]}, "price": "1,000.01", "attrs": {"color": "GREEN", "weight": "10"}, "stock": "0"}, {"id": 103, "meta": {"type": "std", "flags": ["eco"]}, "price": "$0", "attrs": {"color": "green"}, "stock": "0"}]], "output": ["101", "103"]}, {"input": [[{"id": "X", "meta": {"type": "ent", "flags": ["REFURB"]}, "price": "$4500", "attrs": {"size": "9", "color": "blue", "condition": "A"}, "stock": 1}, {"id": "Y", "meta": {"type": "ent", "flags": []}, "price": "$4500", "attrs": {"size": "12", "color": "blue"}, "stock": 0}, {"id": "Z", "meta": {"type": "ent", "flags": []}, "price": "$4500", "attrs": {"size": "12", "color": "blue"}, "stock": 3}]], "output": ["Z"]}, {"input": [[{"id": "bad", "meta": {"type": "other", "flags": ["eco"]}, "price": "100", "attrs": {"color": "red"}, "stock": 1}, {"id": "ok-std", "meta": {"type": "std", "flags": ["eco"]}, "price": "1000", "attrs": {"color": "green"}, "stock": 0}]], "output": ["ok-std"]}, {"input": [[{"id": "keep-pro-over-std", "meta": {"type": "pro", "flags": ["eco"]}, "price": "500", "attrs": {"color": "blue"}}, {"id": "keep-ent-first", "meta": {"type": "ent", "flags": ["eco"]}, "price": "1200", "attrs": {"color": "green", "size": 20}, "stock": 2}, {"id": "keep-std-last", "meta": {"type": "std", "flags": ["eco"]}, "price": "100", "attrs": {"color": "red"}}]], "output": ["keep-ent-first", "keep-pro-over-std", "keep-std-last"]}]}}
{"timestamp_utc": "2025-09-24T16:06:28.950427", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 26, "question": "Write sliding_window_max(arr, k) that returns maximum element in each sliding window of size k using deque. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 15.686180114746094, "response": "def sliding_window_max(arr, k):\n    from collections import deque\n    n = len(arr)\n    if n == 0 or k <= 0 or k > n:\n        return []\n    dq = deque()  # store indices, values in decreasing order\n    res = []\n    for i, val in enumerate(arr):\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        while dq and arr[dq[-1]] < val:\n            dq.pop()\n        dq.append(i)\n        if i >= k - 1:\n            res.append(arr[dq[0]])\n    return res", "error": null, "raw_item": {"task_id": "custom_sliding_window_max", "prompt": "Write sliding_window_max(arr, k) that returns maximum element in each sliding window of size k using deque. Return only the Python function code with no explanations.", "entry_point": "sliding_window_max", "canonical_solution": "from collections import deque\n\ndef sliding_window_max(arr: list[int], k: int) -> list[int]:\n    if not arr or k == 0:\n        return []\n    \n    dq = deque()\n    result = []\n    \n    for i in range(len(arr)):\n        # Remove elements outside current window\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove elements smaller than current element\n        while dq and arr[dq[-1]] <= arr[i]:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Add maximum to result if window is complete\n        if i >= k - 1:\n            result.append(arr[dq[0]])\n    \n    return result", "test": [{"input": [[1, 3, -1, -3, 5, 3, 6, 7], 3], "output": [3, 3, 5, 5, 6, 7]}, {"input": [[1, 2, 3], 1], "output": [1, 2, 3]}, {"input": [[5, 4, 3, 2, 1], 2], "output": [5, 4, 3, 2]}, {"input": [[1], 1], "output": [1]}, {"input": [[], 3], "output": []}, {"input": [[7, 2, 4], 3], "output": [7]}]}}
{"timestamp_utc": "2025-09-24T16:06:47.687128", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 27, "question": "Write rotate_matrix(matrix) that rotates n×n matrix 90 degrees clockwise in-place using transpose and reverse. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 17.735302925109863, "response": "def rotate_matrix(matrix):\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    for row in matrix:\n        row.reverse()", "error": null, "raw_item": {"task_id": "custom_rotate_matrix", "prompt": "Write rotate_matrix(matrix) that rotates n×n matrix 90 degrees clockwise in-place using transpose and reverse. Return only the Python function code with no explanations.", "entry_point": "rotate_matrix", "canonical_solution": "def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]:\n    if not matrix or not matrix[0]:\n        return matrix\n    \n    n = len(matrix)\n    \n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Reverse each row\n    for i in range(n):\n        matrix[i].reverse()\n    \n    return matrix", "test": [{"input": [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]], "output": [[7, 4, 1], [8, 5, 2], [9, 6, 3]]}, {"input": [[[1, 2], [3, 4]]], "output": [[3, 1], [4, 2]]}, {"input": [[[1]]], "output": [[1]]}, {"input": [[]], "output": []}, {"input": [[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]], "output": [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]}]}}
{"timestamp_utc": "2025-09-24T16:07:01.722621", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 28, "question": "Write is_arithmetic_sequence(seq) that checks if sequence forms arithmetic progression with common difference > 0. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 13.033416986465454, "response": "def is_arithmetic_sequence(seq):\n    seq = list(seq)\n    if len(seq) < 2:\n        return False\n    diff = seq[1] - seq[0]\n    if diff <= 0:\n        return False\n    return all((b - a) == diff for a, b in zip(seq, seq[1:]))", "error": null, "raw_item": {"task_id": "alg_arithmetic_sequence", "entry_point": "is_arithmetic_sequence", "prompt": "Write is_arithmetic_sequence(seq) that checks if sequence forms arithmetic progression with common difference > 0. Return only the Python function code with no explanations.", "canonical_solution": "def is_arithmetic_sequence(seq):\n    if len(seq) < 2:\n        return False\n    diff = seq[1] - seq[0]\n    if diff <= 0:\n        return False\n    for i in range(2, len(seq)):\n        if seq[i] - seq[i-1] != diff:\n            return False\n    return True", "test": [{"input": [[1, 3, 5, 7, 9]], "output": true}, {"input": [[2, 4, 6, 8]], "output": true}, {"input": [[5, 5, 5]], "output": false}, {"input": [[1, 2, 4, 8]], "output": false}, {"input": [[10, 5, 0]], "output": false}]}}
{"timestamp_utc": "2025-09-24T16:07:10.628298", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 29, "question": "Write classify_severity(msg) that returns HIGH if msg contains 'error' or 'critical', MEDIUM if contains 'warning', LOW otherwise. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 7.904083013534546, "response": "def classify_severity(msg):\n    s = '' if msg is None else str(msg).lower()\n    if 'error' in s or 'critical' in s:\n        return 'HIGH'\n    if 'warning' in s:\n        return 'MEDIUM'\n    return 'LOW'", "error": null, "raw_item": {"task_id": "se_severity_classifier", "entry_point": "classify_severity", "prompt": "Write classify_severity(msg) that returns HIGH if msg contains 'error' or 'critical', MEDIUM if contains 'warning', LOW otherwise. Return only the Python function code with no explanations.", "canonical_solution": "def classify_severity(msg):\n    msg_lower = msg.lower()\n    if 'error' in msg_lower or 'critical' in msg_lower:\n        return 'HIGH'\n    elif 'warning' in msg_lower:\n        return 'MEDIUM'\n    else:\n        return 'LOW'", "test": [{"input": ["System error occurred"], "output": "HIGH"}, {"input": ["Critical failure detected"], "output": "HIGH"}, {"input": ["Warning: disk space low"], "output": "MEDIUM"}, {"input": ["Info: task completed"], "output": "LOW"}, {"input": ["ERROR in database"], "output": "HIGH"}]}}
{"timestamp_utc": "2025-09-24T16:07:19.337593", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 30, "question": "Write find_peak_index(arr) that finds index of first element that is greater than both neighbors. Return -1 if no peak exists. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 7.707638740539551, "response": "def find_peak_index(arr):\n    n = len(arr)\n    if n < 3:\n        return -1\n    for i in range(1, n - 1):\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n            return i\n    return -1", "error": null, "raw_item": {"task_id": "alg_peak_finder", "entry_point": "find_peak_index", "prompt": "Write find_peak_index(arr) that finds index of first element that is greater than both neighbors. Return -1 if no peak exists. Return only the Python function code with no explanations.", "canonical_solution": "def find_peak_index(arr):\n    if len(arr) < 3:\n        return -1\n    for i in range(1, len(arr) - 1):\n        if arr[i] > arr[i-1] and arr[i] > arr[i+1]:\n            return i\n    return -1", "test": [{"input": [[1, 3, 2, 4, 1]], "output": 1}, {"input": [[1, 2, 3, 2, 1]], "output": 2}, {"input": [[1, 2, 3, 4, 5]], "output": -1}, {"input": [[5, 4, 3, 2, 1]], "output": -1}, {"input": [[1, 3, 1]], "output": 1}]}}
{"timestamp_utc": "2025-09-24T16:07:30.687029", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 31, "question": "def find_anagrams(words: list[str]) -> list[list[str]]:\n    \"\"\"\n    Given a list of words, group anagrams together.\n    Return a list of groups, where each group contains anagrams.\n    Words within each group should be sorted alphabetically.\n    Groups should be sorted by their first word alphabetically.\n\n    Examples:\n    >>> find_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"])\n    [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']]\n\n    >>> find_anagrams([\"hello\", \"world\"])\n    [['hello'], ['world']]\n\n    >>> find_anagrams([])\n    []\n\n    >>> find_anagrams([\"a\", \"aa\", \"aaa\"])\n    [['a'], ['aa'], ['aaa']]\n    \"\"\"", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 10.348324060440063, "response": "Here's a simple, correct implementation:\n\n```python\ndef find_anagrams(words: list[str]) -> list[list[str]]:\n    \"\"\"\n    Group anagrams from the input list. Words in each group are sorted\n    alphabetically. Groups are sorted by their first word alphabetically.\n    \"\"\"\n    if not words:\n        return []\n\n    groups: dict[str, list[str]] = {}\n    for w in words:\n        key = ''.join(sorted(w))\n        groups.setdefault(key, []).append(w)\n\n    # Sort words within each group\n    sorted_groups = [sorted(g) for g in groups.values()]\n\n    # Sort groups by their first word\n    sorted_groups.sort(key=lambda g: g[0])\n    return sorted_groups\n```\n\nThis maps each word to the canonical sorted-letter key, collects groups, sorts words within each group, then sorts the groups by their first member. Complexity ≈ O(n * m log m + n log n) where m is average word length.", "error": null, "raw_item": {"task_id": "custom_find_anagrams", "prompt": "def find_anagrams(words: list[str]) -> list[list[str]]:\n    \"\"\"\n    Given a list of words, group anagrams together.\n    Return a list of groups, where each group contains anagrams.\n    Words within each group should be sorted alphabetically.\n    Groups should be sorted by their first word alphabetically.\n\n    Examples:\n    >>> find_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"])\n    [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']]\n\n    >>> find_anagrams([\"hello\", \"world\"])\n    [['hello'], ['world']]\n\n    >>> find_anagrams([])\n    []\n\n    >>> find_anagrams([\"a\", \"aa\", \"aaa\"])\n    [['a'], ['aa'], ['aaa']]\n    \"\"\"\n    ", "entry_point": "find_anagrams", "canonical_solution": "def find_anagrams(words: list[str]) -> list[list[str]]:\n    from collections import defaultdict\n    \n    anagram_groups = defaultdict(list)\n    \n    for word in words:\n        # Use sorted characters as key\n        key = ''.join(sorted(word))\n        anagram_groups[key].append(word)\n    \n    result = []\n    for group in anagram_groups.values():\n        group.sort()\n        result.append(group)\n    \n    # Sort groups by their first word\n    result.sort(key=lambda x: x[0])\n    \n    return result", "test": [{"input": [["eat", "tea", "tan", "ate", "nat", "bat"]], "output": [["ate", "eat", "tea"], ["bat"], ["nat", "tan"]]}, {"input": [["hello", "world"]], "output": [["hello"], ["world"]]}, {"input": [[]], "output": []}, {"input": [["a", "aa", "aaa"]], "output": [["a"], ["aa"], ["aaa"]]}, {"input": [["abc", "bca", "cab", "xyz"]], "output": [["abc", "bca", "cab"], ["xyz"]]}]}}
{"timestamp_utc": "2025-09-24T16:07:43.761007", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 32, "question": "def merge_intervals(intervals: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Given a list of intervals where intervals[i] = [start_i, end_i],\n    merge all overlapping intervals and return a list of non-overlapping intervals.\n\n    Examples:\n    >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]])\n    [[1, 6], [8, 10], [15, 18]]\n\n    >>> merge_intervals([[1, 4], [4, 5]])\n    [[1, 5]]\n\n    >>> merge_intervals([[1, 4], [0, 2], [3, 5]])\n    [[0, 5]]\n\n    >>> merge_intervals([])\n    []\n    \"\"\"", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 12.070913791656494, "response": "Here's a simple, efficient implementation:\n\n```python\nfrom typing import List\n\ndef merge_intervals(intervals: List[List[int]]) -> List[List[int]]:\n    if not intervals:\n        return []\n\n    intervals_sorted = sorted(intervals, key=lambda x: x[0])\n    merged: List[List[int]] = []\n\n    for start, end in intervals_sorted:\n        if not merged or start > merged[-1][1]:\n            merged.append([start, end])\n        else:\n            merged[-1][1] = max(merged[-1][1], end)\n\n    return merged\n```\n\nNotes:\n- Overlap check uses start <= last_end (implemented as negation start > last_end), so intervals like [1,4] and [4,5] are merged.\n- Time complexity: O(n log n) for sorting. Space: O(n) for the output.", "error": null, "raw_item": {"task_id": "custom_merge_intervals", "prompt": "def merge_intervals(intervals: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Given a list of intervals where intervals[i] = [start_i, end_i],\n    merge all overlapping intervals and return a list of non-overlapping intervals.\n\n    Examples:\n    >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]])\n    [[1, 6], [8, 10], [15, 18]]\n\n    >>> merge_intervals([[1, 4], [4, 5]])\n    [[1, 5]]\n\n    >>> merge_intervals([[1, 4], [0, 2], [3, 5]])\n    [[0, 5]]\n\n    >>> merge_intervals([])\n    []\n    \"\"\"\n    ", "entry_point": "merge_intervals", "canonical_solution": "def merge_intervals(intervals: list[list[int]]) -> list[list[int]]:\n    if not intervals:\n        return []\n    \n    # Sort intervals by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = [intervals[0]]\n    \n    for current in intervals[1:]:\n        last = merged[-1]\n        \n        # Check if current interval overlaps with last merged interval\n        if current[0] <= last[1]:\n            # Merge intervals\n            last[1] = max(last[1], current[1])\n        else:\n            # No overlap, add current interval\n            merged.append(current)\n    \n    return merged", "test": [{"input": [[[1, 3], [2, 6], [8, 10], [15, 18]]], "output": [[1, 6], [8, 10], [15, 18]]}, {"input": [[[1, 4], [4, 5]]], "output": [[1, 5]]}, {"input": [[[1, 4], [0, 2], [3, 5]]], "output": [[0, 5]]}, {"input": [[]], "output": []}, {"input": [[[1, 2]]], "output": [[1, 2]]}, {"input": [[[1, 4], [2, 3]]], "output": [[1, 4]]}]}}
{"timestamp_utc": "2025-09-24T16:08:06.585903", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 33, "question": "def binary_tree_paths(root: dict | None) -> list[str]:\n    \"\"\"\n    Given a binary tree represented as nested dictionaries with 'val', 'left', and 'right' keys,\n    return all root-to-leaf paths as strings with arrows.\n\n    Tree format: {'val': int, 'left': dict|None, 'right': dict|None}\n\n    Examples:\n    >>> binary_tree_paths({'val': 1, 'left': {'val': 2, 'left': None, 'right': {'val': 5, 'left': None, 'right': None}}, 'right': {'val': 3, 'left': None, 'right': None}})\n    ['1->2->5', '1->3']\n\n    >>> binary_tree_paths({'val': 1, 'left': None, 'right': None})\n    ['1']\n\n    >>> binary_tree_paths(None)\n    []\n    \"\"\"", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 21.820183038711548, "response": "Here's a simple recursive implementation:\n\n```python\ndef binary_tree_paths(root: dict | None) -> list[str]:\n    if root is None:\n        return []\n\n    paths: list[str] = []\n\n    def dfs(node: dict | None, path: str) -> None:\n        if node is None:\n            return\n        cur = f\"{path}->{node['val']}\" if path else str(node['val'])\n        if not node.get('left') and not node.get('right'):  # leaf\n            paths.append(cur)\n            return\n        dfs(node.get('left'), cur)\n        dfs(node.get('right'), cur)\n\n    dfs(root, \"\")\n    return paths\n```\n\nThis produces left-first root-to-leaf paths like \"1->2->5\".", "error": null, "raw_item": {"task_id": "custom_binary_tree_paths", "prompt": "def binary_tree_paths(root: dict | None) -> list[str]:\n    \"\"\"\n    Given a binary tree represented as nested dictionaries with 'val', 'left', and 'right' keys,\n    return all root-to-leaf paths as strings with arrows.\n\n    Tree format: {'val': int, 'left': dict|None, 'right': dict|None}\n\n    Examples:\n    >>> binary_tree_paths({'val': 1, 'left': {'val': 2, 'left': None, 'right': {'val': 5, 'left': None, 'right': None}}, 'right': {'val': 3, 'left': None, 'right': None}})\n    ['1->2->5', '1->3']\n\n    >>> binary_tree_paths({'val': 1, 'left': None, 'right': None})\n    ['1']\n\n    >>> binary_tree_paths(None)\n    []\n    \"\"\"\n    ", "entry_point": "binary_tree_paths", "canonical_solution": "def binary_tree_paths(root: dict | None) -> list[str]:\n    if not root:\n        return []\n    \n    paths = []\n    \n    def dfs(node, path):\n        if not node:\n            return\n        \n        # Add current node to path\n        current_path = path + [str(node['val'])]\n        \n        # If leaf node, add path to result\n        if not node['left'] and not node['right']:\n            paths.append('->'.join(current_path))\n            return\n        \n        # Recurse on children\n        if node['left']:\n            dfs(node['left'], current_path)\n        if node['right']:\n            dfs(node['right'], current_path)\n    \n    dfs(root, [])\n    return paths", "test": [{"input": [{"val": 1, "left": {"val": 2, "left": null, "right": {"val": 5, "left": null, "right": null}}, "right": {"val": 3, "left": null, "right": null}}], "output": ["1->2->5", "1->3"]}, {"input": [{"val": 1, "left": null, "right": null}], "output": ["1"]}, {"input": [null], "output": []}, {"input": [{"val": 1, "left": {"val": 2, "left": null, "right": null}, "right": {"val": 3, "left": null, "right": null}}], "output": ["1->2", "1->3"]}]}}
{"timestamp_utc": "2025-09-24T16:08:19.245531", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 34, "question": "def word_pattern(pattern: str, s: str) -> bool:\n    \"\"\"\n    Given a pattern and a string s, find if s follows the same pattern.\n    Here follow means a full match, such that there is a bijection between\n    a letter in pattern and a non-empty word in s.\n\n    Examples:\n    >>> word_pattern(\"abba\", \"dog cat cat dog\")\n    True\n\n    >>> word_pattern(\"abba\", \"dog cat cat fish\")\n    False\n\n    >>> word_pattern(\"aaaa\", \"dog cat cat dog\")\n    False\n\n    >>> word_pattern(\"abba\", \"dog dog dog dog\")\n    False\n    \"\"\"", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 11.654351949691772, "response": "Here's a concise implementation that enforces a bijection between pattern letters and words:\n\n```python\ndef word_pattern(pattern: str, s: str) -> bool:\n    \"\"\"\n    Given a pattern and a string s, find if s follows the same pattern.\n    There must be a bijection between a letter in pattern and a non-empty word in s.\n    \"\"\"\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    p2w = {}\n    w2p = {}\n    for p, w in zip(pattern, words):\n        if p in p2w:\n            if p2w[p] != w:\n                return False\n        else:\n            if w in w2p:  # word already mapped to another pattern char\n                return False\n            p2w[p] = w\n            w2p[w] = p\n\n    return True\n```\n\nQuick check with your examples:\n- word_pattern(\"abba\", \"dog cat cat dog\") -> True\n- word_pattern(\"abba\", \"dog cat cat fish\") -> False\n- word_pattern(\"aaaa\", \"dog cat cat dog\") -> False\n- word_pattern(\"abba\", \"dog dog dog dog\") -> False", "error": null, "raw_item": {"task_id": "custom_word_pattern", "prompt": "def word_pattern(pattern: str, s: str) -> bool:\n    \"\"\"\n    Given a pattern and a string s, find if s follows the same pattern.\n    Here follow means a full match, such that there is a bijection between\n    a letter in pattern and a non-empty word in s.\n\n    Examples:\n    >>> word_pattern(\"abba\", \"dog cat cat dog\")\n    True\n\n    >>> word_pattern(\"abba\", \"dog cat cat fish\")\n    False\n\n    >>> word_pattern(\"aaaa\", \"dog cat cat dog\")\n    False\n\n    >>> word_pattern(\"abba\", \"dog dog dog dog\")\n    False\n    \"\"\"\n    ", "entry_point": "word_pattern", "canonical_solution": "def word_pattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    \n    if len(pattern) != len(words):\n        return False\n    \n    char_to_word = {}\n    word_to_char = {}\n    \n    for char, word in zip(pattern, words):\n        # Check char -> word mapping\n        if char in char_to_word:\n            if char_to_word[char] != word:\n                return False\n        else:\n            char_to_word[char] = word\n        \n        # Check word -> char mapping (bijection)\n        if word in word_to_char:\n            if word_to_char[word] != char:\n                return False\n        else:\n            word_to_char[word] = char\n    \n    return True", "test": [{"input": ["abba", "dog cat cat dog"], "output": true}, {"input": ["abba", "dog cat cat fish"], "output": false}, {"input": ["aaaa", "dog cat cat dog"], "output": false}, {"input": ["abba", "dog dog dog dog"], "output": false}, {"input": ["abc", "dog cat fish"], "output": true}, {"input": ["a", "dog"], "output": true}, {"input": ["ab", "dog"], "output": false}]}}
{"timestamp_utc": "2025-09-24T16:08:36.934500", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 35, "question": "class MinStack:\n    \"\"\"\n    Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n    Implement the MinStack class:\n    - MinStack() initializes the stack object.\n    - push(val) pushes the element val onto the stack.\n    - pop() removes the element on the top of the stack.\n    - top() gets the top element of the stack.\n    - get_min() retrieves the minimum element in the stack.\n\n    You must implement a solution with O(1) time complexity for each function.\n\n    Examples:\n    >>> stack = MinStack()\n    >>> stack.push(-2)\n    >>> stack.push(0)\n    >>> stack.push(-3)\n    >>> stack.get_min()\n    -3\n    >>> stack.pop()\n    >>> stack.top()\n    0\n    >>> stack.get_min()\n    -2\n    \"\"\"", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 16.68538212776184, "response": "class MinStack:\n    \"\"\"\n    Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n    Methods:\n    - MinStack() initializes the stack object.\n    - push(val) pushes the element val onto the stack.\n    - pop() removes the element on the top of the stack.\n    - top() gets the top element of the stack.\n    - get_min() retrieves the minimum element in the stack.\n\n    All operations run in O(1) time.\n    \"\"\"\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        # push onto min_stack when it's empty or val is <= current min\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if not self.stack:\n            raise IndexError(\"pop from empty stack\")\n        val = self.stack.pop()\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        if not self.stack:\n            raise IndexError(\"top from empty stack\")\n        return self.stack[-1]\n\n    def get_min(self):\n        if not self.min_stack:\n            raise IndexError(\"get_min from empty stack\")\n        return self.min_stack[-1]", "error": null, "raw_item": {"task_id": "custom_min_stack", "prompt": "class MinStack:\n    \"\"\"\n    Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n    Implement the MinStack class:\n    - MinStack() initializes the stack object.\n    - push(val) pushes the element val onto the stack.\n    - pop() removes the element on the top of the stack.\n    - top() gets the top element of the stack.\n    - get_min() retrieves the minimum element in the stack.\n\n    You must implement a solution with O(1) time complexity for each function.\n\n    Examples:\n    >>> stack = MinStack()\n    >>> stack.push(-2)\n    >>> stack.push(0)\n    >>> stack.push(-3)\n    >>> stack.get_min()\n    -3\n    >>> stack.pop()\n    >>> stack.top()\n    0\n    >>> stack.get_min()\n    -2\n    \"\"\"\n    ", "entry_point": "MinStack", "canonical_solution": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        # Push to min_stack if it's empty or val is <= current minimum\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self) -> None:\n        if self.stack:\n            val = self.stack.pop()\n            # Pop from min_stack if the popped value was the minimum\n            if self.min_stack and val == self.min_stack[-1]:\n                self.min_stack.pop()\n    \n    def top(self) -> int:\n        return self.stack[-1] if self.stack else None\n    \n    def get_min(self) -> int:\n        return self.min_stack[-1] if self.min_stack else None", "test": [{"input": [["MinStack", "push", "push", "push", "get_min", "pop", "top", "get_min"], [[], [-2], [0], [-3], [], [], [], []]], "output": [null, null, null, null, -3, null, 0, -2]}, {"input": [["MinStack", "push", "push", "get_min", "get_min", "pop", "get_min"], [[], [1], [2], [], [], [], []]], "output": [null, null, null, 1, 1, null, 1]}, {"input": [["MinStack", "push", "get_min", "pop", "push", "get_min"], [[], [1], [], [], [2], []]], "output": [null, null, 1, null, null, 2]}]}}
{"timestamp_utc": "2025-09-24T16:08:58.997310", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 36, "question": "class LRUCache:\n    \"\"\"\n    Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\n    Implement the LRUCache class:\n    - LRUCache(capacity) Initialize the LRU cache with positive size capacity.\n    - get(key) Return the value of the key if the key exists, otherwise return -1.\n    - put(key, value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.\n      If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\n    The functions get and put must each run in O(1) average time complexity.\n\n    Examples:\n    >>> cache = LRUCache(2)\n    >>> cache.put(1, 1)\n    >>> cache.put(2, 2)\n    >>> cache.get(1)\n    1\n    >>> cache.put(3, 3)\n    >>> cache.get(2)\n    -1\n    >>> cache.put(4, 4)\n    >>> cache.get(1)\n    -1\n    >>> cache.get(3)\n    3\n    >>> cache.get(4)\n    4\n    \"\"\"", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 21.06005311012268, "response": "Here's a clean O(1) implementation using a doubly-linked list + dictionary (hash map). The linked list keeps items in recency order (most recent at the front), and the dictionary maps keys to nodes for O(1) access.\n\n```python\nclass Node:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        if capacity <= 0:\n            raise ValueError(\"Capacity must be positive\")\n        self.capacity = capacity\n        self.cache = {}  # key -> Node\n        # dummy head and tail to avoid edge checks\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # helper: add node right after head (most recent)\n    def _add_node(self, node: Node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    # helper: remove node from list\n    def _remove_node(self, node: Node):\n        prev, nxt = node.prev, node.next\n        prev.next = nxt\n        nxt.prev = prev\n\n    # helper: move existing node to front (most recent)\n    def _move_to_front(self, node: Node):\n        self._remove_node(node)\n        self._add_node(node)\n\n    # helper: pop the least recently used node (right before tail)\n    def _pop_tail(self) -> Node:\n        node = self.tail.prev\n        self._remove_node(node)\n        return node\n\n    def get(self, key: int) -> int:\n        node = self.cache.get(key)\n        if not node:\n            return -1\n        # mark as recently used\n        self._move_to_front(node)\n        return node.val\n\n    def put(self, key: int, value: int) -> None:\n        node = self.cache.get(key)\n        if node:\n            node.val = value\n            self._move_to_front(node)\n        else:\n            new_node = Node(key, value)\n            self.cache[key] = new_node\n            self._add_node(new_node)\n            if len(self.cache) > self.capacity:\n                # evict LRU\n                tail = self._pop_tail()\n                del self.cache[tail.key]\n```\n\nExample usage:\n\n```python\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nprint(cache.get(1))   # 1\ncache.put(3, 3)       # evicts key 2\nprint(cache.get(2))   # -1\ncache.put(4, 4)       # evicts key 1\nprint(cache.get(1))   # -1\nprint(cache.get(3))   # 3\nprint(cache.get(4))   # 4\n```\n\nComplexity: get and put are O(1) average time, O(1) space per entry.", "error": null, "raw_item": {"task_id": "custom_lru_cache", "prompt": "class LRUCache:\n    \"\"\"\n    Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\n    Implement the LRUCache class:\n    - LRUCache(capacity) Initialize the LRU cache with positive size capacity.\n    - get(key) Return the value of the key if the key exists, otherwise return -1.\n    - put(key, value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.\n      If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\n    The functions get and put must each run in O(1) average time complexity.\n\n    Examples:\n    >>> cache = LRUCache(2)\n    >>> cache.put(1, 1)\n    >>> cache.put(2, 2)\n    >>> cache.get(1)\n    1\n    >>> cache.put(3, 3)\n    >>> cache.get(2)\n    -1\n    >>> cache.put(4, 4)\n    >>> cache.get(1)\n    -1\n    >>> cache.get(3)\n    3\n    >>> cache.get(4)\n    4\n    \"\"\"\n    ", "entry_point": "LRUCache", "canonical_solution": "class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        # Use a list to maintain order (least recent at index 0)\n        self.order = []\n    \n    def get(self, key: int) -> int:\n        if key in self.cache:\n            # Move to end (most recently used)\n            self.order.remove(key)\n            self.order.append(key)\n            return self.cache[key]\n        return -1\n    \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # Update existing key\n            self.cache[key] = value\n            self.order.remove(key)\n            self.order.append(key)\n        else:\n            # Add new key\n            if len(self.cache) >= self.capacity:\n                # Remove least recently used\n                lru_key = self.order.pop(0)\n                del self.cache[lru_key]\n            \n            self.cache[key] = value\n            self.order.append(key)", "test": [{"input": [["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]], "output": [null, null, null, 1, null, -1, null, -1, 3, 4]}, {"input": [["LRUCache", "put", "get", "put", "get", "get"], [[1], [2, 1], [2], [3, 2], [2], [3]]], "output": [null, null, 1, null, -1, 2]}]}}
{"timestamp_utc": "2025-09-24T16:09:23.096231", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 37, "question": "def validate_ip_address(ip: str) -> str:\n    \"\"\"\n    Given a string ip, return \"IPv4\" if it's a valid IPv4 address,\n    \"IPv6\" if it's a valid IPv6 address, or \"Neither\" if it's not a valid IP address.\n\n    IPv4 rules:\n    - Four decimal numbers separated by dots\n    - Each number is 0-255\n    - No leading zeros except for \"0\" itself\n\n    IPv6 rules:\n    - Eight hexadecimal groups separated by colons\n    - Each group is 1-4 hexadecimal digits\n    - Leading zeros in a group are allowed\n\n    Examples:\n    >>> validate_ip_address(\"172.16.254.1\")\n    \"IPv4\"\n\n    >>> validate_ip_address(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")\n    \"IPv6\"\n\n    >>> validate_ip_address(\"256.256.256.256\")\n    \"Neither\"\n\n    >>> validate_ip_address(\"192.168.1.1.1\")\n    \"Neither\"\n    \"\"\"", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 23.093679904937744, "response": "Here's a straightforward implementation that follows the rules you gave:\n\n```python\ndef validate_ip_address(ip: str) -> str:\n    \"\"\"\n    Given a string ip, return \"IPv4\" if it's a valid IPv4 address,\n    \"IPv6\" if it's a valid IPv6 address, or \"Neither\" if it's not a valid IP address.\n    \"\"\"\n    # Check IPv4\n    if ip.count('.') == 3 and ':' not in ip:\n        parts = ip.split('.')\n        if len(parts) == 4:\n            for p in parts:\n                # each part must be non-empty and only digits\n                if not p or not p.isdigit():\n                    return \"Neither\"\n                # no leading zeros unless the part is \"0\"\n                if p[0] == '0' and len(p) > 1:\n                    return \"Neither\"\n                # length and range checks\n                if len(p) > 3:\n                    return \"Neither\"\n                if int(p) < 0 or int(p) > 255:\n                    return \"Neither\"\n            return \"IPv4\"\n\n    # Check IPv6\n    if ip.count(':') == 7 and '.' not in ip:\n        parts = ip.split(':')\n        if len(parts) == 8:\n            hexdigits = set('0123456789abcdefABCDEF')\n            for p in parts:\n                # each part must be non-empty and 1-4 hex digits\n                if not p or len(p) > 4:\n                    return \"Neither\"\n                if not all(c in hexdigits for c in p):\n                    return \"Neither\"\n            return \"IPv6\"\n\n    return \"Neither\"\n```\n\nThis rejects IPv6 compressed forms (like \"::\") and enforces the exact rules you listed.", "error": null, "raw_item": {"task_id": "custom_validate_ip_address", "prompt": "def validate_ip_address(ip: str) -> str:\n    \"\"\"\n    Given a string ip, return \"IPv4\" if it's a valid IPv4 address,\n    \"IPv6\" if it's a valid IPv6 address, or \"Neither\" if it's not a valid IP address.\n\n    IPv4 rules:\n    - Four decimal numbers separated by dots\n    - Each number is 0-255\n    - No leading zeros except for \"0\" itself\n\n    IPv6 rules:\n    - Eight hexadecimal groups separated by colons\n    - Each group is 1-4 hexadecimal digits\n    - Leading zeros in a group are allowed\n\n    Examples:\n    >>> validate_ip_address(\"172.16.254.1\")\n    \"IPv4\"\n\n    >>> validate_ip_address(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")\n    \"IPv6\"\n\n    >>> validate_ip_address(\"256.256.256.256\")\n    \"Neither\"\n\n    >>> validate_ip_address(\"192.168.1.1.1\")\n    \"Neither\"\n    \"\"\"\n    ", "entry_point": "validate_ip_address", "canonical_solution": "def validate_ip_address(ip: str) -> str:\n    def is_valid_ipv4(ip):\n        parts = ip.split('.')\n        if len(parts) != 4:\n            return False\n        \n        for part in parts:\n            if not part or len(part) > 3:\n                return False\n            \n            # Check for leading zeros\n            if len(part) > 1 and part[0] == '0':\n                return False\n            \n            # Check if all characters are digits\n            if not part.isdigit():\n                return False\n            \n            # Check range\n            num = int(part)\n            if num < 0 or num > 255:\n                return False\n        \n        return True\n    \n    def is_valid_ipv6(ip):\n        parts = ip.split(':')\n        if len(parts) != 8:\n            return False\n        \n        for part in parts:\n            if not part or len(part) > 4:\n                return False\n            \n            # Check if all characters are valid hex\n            for char in part:\n                if char not in '0123456789abcdefABCDEF':\n                    return False\n        \n        return True\n    \n    if is_valid_ipv4(ip):\n        return \"IPv4\"\n    elif is_valid_ipv6(ip):\n        return \"IPv6\"\n    else:\n        return \"Neither\"", "test": [{"input": ["172.16.254.1"], "output": "IPv4"}, {"input": ["2001:0db8:85a3:0000:0000:8a2e:0370:7334"], "output": "IPv6"}, {"input": ["256.256.256.256"], "output": "Neither"}, {"input": ["192.168.1.1.1"], "output": "Neither"}, {"input": ["192.168.01.1"], "output": "Neither"}, {"input": ["2001:0db8:85a3::8a2e:0370:7334"], "output": "Neither"}, {"input": [""], "output": "Neither"}]}}
{"timestamp_utc": "2025-09-24T16:09:43.072594", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 38, "question": "Merge two dictionaries with integer values by keeping the maximum value for each key.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 18.974054098129272, "response": "Here are concise ways to merge two maps/dictionaries so each key keeps the maximum integer value.\n\nPython\n\n- Non-destructive (creates a new dict):\n  ```\n  d1 = {'a': 1, 'b': 3}\n  d2 = {'b': 2, 'c': 4}\n\n  merged = {k: max(d1.get(k, float('-inf')), d2.get(k, float('-inf')))\n            for k in set(d1) | set(d2)}\n  # merged -> {'a': 1, 'b': 3, 'c': 4}\n  ```\n\n- In-place (update a copy or d1 itself):\n  ```\n  res = d1.copy()\n  for k, v in d2.items():\n      res[k] = max(res.get(k, v), v)\n  ```\n\nJavaScript\n\n```\nconst d1 = {a: 1, b: 3};\nconst d2 = {b: 2, c: 4};\n\nconst merged = {...d1};\nfor (const [k, v] of Object.entries(d2)) {\n  merged[k] = Math.max(merged[k] ?? v, v);\n}\n// merged -> {a:1, b:3, c:4}\n```\n\nIf you want an example in another language or need to handle missing/negative values specially, tell me which language and constraints.", "error": null, "raw_item": {"task_id": "MyBench/dict_merge_max", "prompt": "Merge two dictionaries with integer values by keeping the maximum value for each key.", "entry_point": "merge_max", "canonical_solution": "def merge_max(d1, d2):\n    out = dict(d1)\n    for k,v in d2.items():\n        out[k] = max(out.get(k, v), v)\n    return out", "test": [{"input": [{"a": 1, "b": 5}, {"b": 3, "c": 10}], "output": {"a": 1, "b": 5, "c": 10}}, {"input": [{}, {"x": 7}], "output": {"x": 7}}, {"input": [{"a": 5}, {"a": 5}], "output": {"a": 5}}, {"input": [{"m": -1, "n": 2}, {"m": -5, "o": 10}], "output": {"m": -1, "n": 2, "o": 10}}, {"input": [{}, {}], "output": {}}]}}
{"timestamp_utc": "2025-09-24T16:10:16.345026", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 39, "question": "Invert a dictionary where values may not be unique. Return a new dictionary mapping each value to a list of keys that had that value.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 32.27007007598877, "response": "Here's a simple Python function that inverts a dict where values may repeat. Each value becomes a key in the result, mapped to a list of original keys that had that value.\n\nCode (Python 3.7+ — preserves insertion order):\n\n    from collections import defaultdict\n    from typing import Dict, List, TypeVar\n\n    K = TypeVar('K')\n    V = TypeVar('V')\n\n    def invert_dict(d: Dict[K, V]) -> Dict[V, List[K]]:\n        inv: Dict[V, List[K]] = defaultdict(list)\n        for k, v in d.items():\n            inv[v].append(k)\n        return dict(inv)\n\nExample:\n\n    d = {'a': 1, 'b': 2, 'c': 1, 'd': 3}\n    invert_dict(d)\n    # -> {1: ['a', 'c'], 2: ['b'], 3: ['d']}\n\nNotes:\n- Values must be hashable to become keys in the inverted dict (otherwise you'll get a TypeError).\n- The lists preserve the order of keys as they appear in the original dictionary.", "error": null, "raw_item": {"task_id": "dict_invert_multival", "prompt": "Invert a dictionary where values may not be unique. Return a new dictionary mapping each value to a list of keys that had that value.", "entry_point": "invert_multival", "canonical_solution": "def invert_multival(d):\n    out={}\n    for k,v in d.items():\n        out.setdefault(v, []).append(k)\n    return out", "test": [{"input": [{"a": 1, "b": 2, "c": 1}], "output": {"1": ["a", "c"], "2": ["b"]}}, {"input": [{}], "output": {}}, {"input": [{"x": "hi", "y": "hi", "z": "bye"}], "output": {"hi": ["x", "y"], "bye": ["z"]}}, {"input": [{"p": 0, "q": 0, "r": 0}], "output": {"0": ["p", "q", "r"]}}, {"input": [{"k": 42}], "output": {"42": ["k"]}}]}}
{"timestamp_utc": "2025-09-24T16:10:43.276026", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 40, "question": "Return True if an integer has even parity (even number of 1 bits in binary), else False.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 25.928921937942505, "response": "Here's a concise Python function. It treats negative integers by parity of their absolute value's bits (i.e., counts 1-bits in the magnitude):\n\ndef even_parity(n):\n    \"\"\"Return True if integer n has an even number of 1-bits, else False.\"\"\"\n    n = abs(int(n))\n    parity = 0\n    while n:\n        parity ^= 1\n        n &= n - 1\n    return parity == 0\n\nQuick one-liner alternative:\n\ndef even_parity(n):\n    return bin(abs(int(n))).count('1') % 2 == 0\n\nExamples:\n- even_parity(0) -> True (0 ones)\n- even_parity(3) -> True (binary 11 has two 1s)\n- even_parity(5) -> False (binary 101 has two 1s? actually 2 -> True)", "error": null, "raw_item": {"task_id": "bitwise_parity", "prompt": "Return True if an integer has even parity (even number of 1 bits in binary), else False.", "entry_point": "even_parity", "canonical_solution": "def even_parity(n):\n    c=0\n    while n:\n        n&=n-1\n        c^=1\n    return c==0", "test": [{"input": [3], "output": false}, {"input": [5], "output": true}, {"input": [0], "output": true}, {"input": [15], "output": true}, {"input": [16], "output": false}, {"input": [255], "output": true}]}}
{"timestamp_utc": "2025-09-24T16:10:57.948963", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 41, "question": "Swap two integers without using a temporary variable, using bitwise XOR. Return the swapped pair as a tuple. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 13.670885801315308, "response": "def swap_xor(a, b):\n    a ^= b\n    b ^= a\n    a ^= b\n    return a, b", "error": null, "raw_item": {"task_id": "bitwise_swap", "prompt": "Swap two integers without using a temporary variable, using bitwise XOR. Return the swapped pair as a tuple. Return only the Python function code with no explanations.", "entry_point": "swap_xor", "canonical_solution": "def swap_xor(a,b):\n    a=a^b; b=a^b; a=a^b\n    return (a,b)", "test": [{"input": [2, 5], "output": [5, 2]}, {"input": [0, 7], "output": [7, 0]}, {"input": [-3, 9], "output": [9, -3]}, {"input": [42, 42], "output": [42, 42]}, {"input": [1000000, 123456], "output": [123456, 1000000]}]}}
{"timestamp_utc": "2025-09-24T16:11:05.803269", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 42, "question": "Compute factorial of n recursively. Assume n >= 0. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 6.8517351150512695, "response": "def factorial(n: int) -> int:\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)", "error": null, "raw_item": {"task_id": "recursion_factorial", "prompt": "Compute factorial of n recursively. Assume n >= 0. Return only the Python function code with no explanations.", "entry_point": "factorial", "canonical_solution": "def factorial(n):\n    return 1 if n<=1 else n*factorial(n-1)", "test": [{"input": [0], "output": 1}, {"input": [1], "output": 1}, {"input": [5], "output": 120}, {"input": [10], "output": 3628800}, {"input": [3], "output": 6}]}}
{"timestamp_utc": "2025-09-24T16:11:23.313449", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 43, "question": "Return the BFS traversal order of a graph represented as adjacency list dict, starting from given node. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 16.50880002975464, "response": "from collections import deque\n\ndef bfs_traversal(graph, start):\n    visited = {start}\n    order = []\n    q = deque([start])\n    while q:\n        node = q.popleft()\n        order.append(node)\n        for nbr in graph.get(node, []):\n            if nbr not in visited:\n                visited.add(nbr)\n                q.append(nbr)\n    return order", "error": null, "raw_item": {"task_id": "graph_bfs_order", "prompt": "Return the BFS traversal order of a graph represented as adjacency list dict, starting from given node. Return only the Python function code with no explanations.", "entry_point": "bfs_order", "canonical_solution": "from collections import deque\n\ndef bfs_order(graph,start):\n    seen={start}; q=deque([start]); order=[]\n    while q:\n        u=q.popleft(); order.append(u)\n        for v in sorted(graph.get(u,[])):\n            if v not in seen:\n                seen.add(v); q.append(v)\n    return order", "test": [{"input": [{"A": ["B", "C"], "B": ["D"], "C": [], "D": []}, "A"], "output": ["A", "B", "C", "D"]}, {"input": [{"1": ["2"], "2": ["3"], "3": []}, "1"], "output": ["1", "2", "3"]}, {"input": [{"x": []}, "x"], "output": ["x"]}, {"input": [{"a": ["b"], "b": ["a"]}, "a"], "output": ["a", "b"]}, {"input": [{"m": ["n", "o"], "n": [], "o": []}, "m"], "output": ["m", "n", "o"]}]}}
{"timestamp_utc": "2025-09-24T16:11:48.913351", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 44, "question": "Given a CSV string with header 'name,value' and multiple rows, return the sum of the 'value' column as int. Assume comma-separated, no quotes. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 24.59830093383789, "response": "def sum_values(csv_str: str) -> int:\n    lines = [line for line in csv_str.splitlines() if line.strip()]\n    if not lines:\n        return 0\n    header = [h.strip() for h in lines[0].split(',')]\n    try:\n        idx = header.index('value')\n    except ValueError:\n        return 0\n    total = 0\n    for line in lines[1:]:\n        parts = [p.strip() for p in line.split(',')]\n        if idx >= len(parts):\n            continue\n        if parts[idx] == '':\n            continue\n        total += int(parts[idx])\n    return total", "error": null, "raw_item": {"task_id": "parsing_csv_sum", "prompt": "Given a CSV string with header 'name,value' and multiple rows, return the sum of the 'value' column as int. Assume comma-separated, no quotes. Return only the Python function code with no explanations.", "entry_point": "csv_sum", "canonical_solution": "def csv_sum(text):\n    lines=text.strip().split('\\n')\n    if len(lines) <= 1:\n        return 0\n    total=0\n    for line in lines[1:]:\n        if line.strip():\n            name,val=line.split(',')\n            total+=int(val)\n    return total", "test": [{"input": ["name,value\\na,3\\nb,7\\nc,10"], "output": 20}, {"input": ["name,value\\n"], "output": 0}, {"input": ["name,value\\nfoo,0\\nbar,0"], "output": 0}, {"input": ["name,value\\nx,100"], "output": 100}, {"input": ["name,value\\na,1\\nb,2\\nc,3\\nd,4"], "output": 10}]}}
{"timestamp_utc": "2025-09-24T16:11:58.049728", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 45, "question": "Extract all sequences of digits from a string using regex and return them as a list of strings. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 8.134567022323608, "response": "def extract_digit_sequences(s: str) -> list[str]:\n    import re\n    return re.findall(r'\\d+', s)", "error": null, "raw_item": {"task_id": "parsing_regex_digits", "prompt": "Extract all sequences of digits from a string using regex and return them as a list of strings. Return only the Python function code with no explanations.", "entry_point": "extract_digits", "canonical_solution": "import re\n\ndef extract_digits(s):\n    return re.findall(r'\\d+', s)", "test": [{"input": ["abc123de45f6"], "output": ["123", "45", "6"]}, {"input": ["no digits here"], "output": []}, {"input": ["2025year"], "output": ["2025"]}, {"input": ["a1b2c3d4"], "output": ["1", "2", "3", "4"]}, {"input": ["007bond"], "output": ["007"]}]}}
{"timestamp_utc": "2025-09-24T16:12:06.526336", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 46, "question": "Return the length of the longest increasing subsequence (LIS) in a list of integers. O(n^2) solution is fine. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 7.4736008644104, "response": "def lis_length(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "error": null, "raw_item": {"task_id": "algorithms_longest_increasing", "prompt": "Return the length of the longest increasing subsequence (LIS) in a list of integers. O(n^2) solution is fine. Return only the Python function code with no explanations.", "entry_point": "lis_length", "canonical_solution": "def lis_length(nums):\n    if not nums: return 0\n    dp=[1]*len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[j]<nums[i]:\n                dp[i]=max(dp[i],dp[j]+1)\n    return max(dp)", "test": [{"input": [[10, 9, 2, 5, 3, 7, 101, 18]], "output": 4}, {"input": [[1, 2, 3, 4, 5]], "output": 5}, {"input": [[5, 4, 3, 2, 1]], "output": 1}, {"input": [[]], "output": 0}, {"input": [[2, 2, 2]], "output": 1}]}}
{"timestamp_utc": "2025-09-24T16:12:33.055505", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 47, "question": "0/1 Knapsack: given weights, values, and capacity W, return the maximum achievable value. Use DP. weights and values are equal length. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 25.527481079101562, "response": "def knapsack(weights, values, W):\n    if W <= 0 or not weights:\n        return 0\n    n = len(weights)\n    dp = [0] * (W + 1)\n    for i in range(n):\n        w = weights[i]\n        v = values[i]\n        if w > W:\n            continue\n        for cap in range(W, w - 1, -1):\n            candidate = dp[cap - w] + v\n            if candidate > dp[cap]:\n                dp[cap] = candidate\n    return dp[W]", "error": null, "raw_item": {"task_id": "algorithms_knapsack01", "prompt": "0/1 Knapsack: given weights, values, and capacity W, return the maximum achievable value. Use DP. weights and values are equal length. Return only the Python function code with no explanations.", "entry_point": "knapsack01", "canonical_solution": "def knapsack01(weights, values, W):\n    n=len(weights)\n    dp=[[0]*(W+1) for _ in range(n+1)]\n    for i in range(1,n+1):\n        for w in range(W+1):\n            dp[i][w]=dp[i-1][w]\n            if weights[i-1]<=w:\n                dp[i][w]=max(dp[i][w], values[i-1]+dp[i-1][w-weights[i-1]])\n    return dp[n][W]", "test": [{"input": [[2, 3, 4], [4, 5, 6], 5], "output": 9}, {"input": [[1, 2, 3], [6, 10, 12], 5], "output": 22}, {"input": [[5], [10], 5], "output": 10}, {"input": [[5], [10], 4], "output": 0}, {"input": [[], [], 10], "output": 0}]}}
{"timestamp_utc": "2025-09-24T16:12:52.401254", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 48, "question": "Write parse_csv_numbers(text) that parses a CSV string of integers separated by commas and newlines. Return a 2D list of integers. Ignore empty lines. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 18.342683792114258, "response": "def parse_csv_numbers(text):\n    rows = []\n    for line in text.splitlines():\n        if not line.strip():\n            continue\n        parts = [p.strip() for p in line.split(',')]\n        nums = []\n        for p in parts:\n            if p == '':\n                continue\n            nums.append(int(p))\n        rows.append(nums)\n    return rows", "error": null, "raw_item": {"task_id": "custom_parse_csv_numbers", "prompt": "Write parse_csv_numbers(text) that parses a CSV string of integers separated by commas and newlines. Return a 2D list of integers. Ignore empty lines. Return only the Python function code with no explanations.", "entry_point": "parse_csv_numbers", "canonical_solution": "def parse_csv_numbers(text: str) -> list[list[int]]:\n    rows = []\n    for line in text.strip().splitlines():\n        if not line.strip():\n            continue\n        row = [int(x.strip()) for x in line.split(',') if x.strip()]\n        rows.append(row)\n    return rows", "test": [{"input": ["1,2,3\n4,5,6"], "output": [[1, 2, 3], [4, 5, 6]]}, {"input": ["10,20\n30\n\n40,50"], "output": [[10, 20], [30], [40, 50]]}, {"input": ["   7 , 8 ,9  "], "output": [[7, 8, 9]]}, {"input": [""], "output": []}]}}
{"timestamp_utc": "2025-09-24T16:13:06.938991", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 49, "question": "Write normalize_json_keys(obj) that recursively converts all dictionary keys in a JSON-like object to lowercase strings. Works for nested dicts and lists. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 13.534168243408203, "response": "def normalize_json_keys(obj):\n    if isinstance(obj, dict):\n        new = {}\n        for k, v in obj.items():\n            new_key = str(k).lower()\n            new[new_key] = normalize_json_keys(v)\n        return new\n    if isinstance(obj, list):\n        return [normalize_json_keys(item) for item in obj]\n    return obj", "error": null, "raw_item": {"task_id": "custom_normalize_json_keys", "prompt": "Write normalize_json_keys(obj) that recursively converts all dictionary keys in a JSON-like object to lowercase strings. Works for nested dicts and lists. Return only the Python function code with no explanations.", "entry_point": "normalize_json_keys", "canonical_solution": "def normalize_json_keys(obj):\n    if isinstance(obj, dict):\n        return {str(k).lower(): normalize_json_keys(v) for k, v in obj.items()}\n    if isinstance(obj, list):\n        return [normalize_json_keys(x) for x in obj]\n    return obj", "test": [{"input": [{"Name": "Alice", "AGE": 30}], "output": {"name": "Alice", "age": 30}}, {"input": [[{"X": 1}, {"Y": 2}]], "output": [{"x": 1}, {"y": 2}]}, {"input": [{"Nested": {"KEY": 5}}], "output": {"nested": {"key": 5}}}, {"input": [123], "output": 123}]}}
{"timestamp_utc": "2025-09-24T16:13:22.411138", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 50, "question": "Write format_duration(seconds) that converts an integer number of seconds into a human-readable string using years, days, hours, minutes, and seconds. Skip units that are zero. Use plural form when needed. Example: 3661 → '1 hour, 1 minute, 1 second'. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 14.469388961791992, "response": "def format_duration(seconds):\n    if not isinstance(seconds, int):\n        raise TypeError(\"seconds must be an integer\")\n    if seconds < 0:\n        raise ValueError(\"seconds must be non-negative\")\n\n    units = [\n        (\"year\", 365 * 24 * 3600),\n        (\"day\", 24 * 3600),\n        (\"hour\", 3600),\n        (\"minute\", 60),\n        (\"second\", 1),\n    ]\n\n    if seconds == 0:\n        return \"0 seconds\"\n\n    parts = []\n    for name, sec_per in units:\n        value, seconds = divmod(seconds, sec_per)\n        if value:\n            parts.append(f\"{value} {name}\" + (\"s\" if value != 1 else \"\"))\n\n    return \", \".join(parts)", "error": null, "raw_item": {"task_id": "custom_format_duration", "prompt": "Write format_duration(seconds) that converts an integer number of seconds into a human-readable string using years, days, hours, minutes, and seconds. Skip units that are zero. Use plural form when needed. Example: 3661 → '1 hour, 1 minute, 1 second'. Return only the Python function code with no explanations.", "entry_point": "format_duration", "canonical_solution": "def format_duration(seconds: int) -> str:\n    units = [(\"year\", 365*24*3600), (\"day\", 24*3600), (\"hour\", 3600), (\"minute\", 60), (\"second\", 1)]\n    parts = []\n    for name, length in units:\n        if seconds >= length:\n            count, seconds = divmod(seconds, length)\n            parts.append(f\"{count} {name}{'s' if count != 1 else ''}\")\n    return \", \".join(parts) if parts else \"0 seconds\"", "test": [{"input": [0], "output": "0 seconds"}, {"input": [62], "output": "1 minute, 2 seconds"}, {"input": [3661], "output": "1 hour, 1 minute, 1 second"}, {"input": [31536000], "output": "1 year"}, {"input": [31556926], "output": "1 year, 6 hours, 9 minutes, 26 seconds"}]}}
{"timestamp_utc": "2025-09-24T16:13:36.958815", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 51, "question": "Write parse_key_value_config(text) that parses a configuration string with lines of the form 'key=value'. Ignore blank lines and lines starting with '#'. Return a dictionary with string keys and values converted to int if possible, else string. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 13.54609489440918, "response": "def parse_key_value_config(text):\n    result = {}\n    for line in text.splitlines():\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        if '=' not in line:\n            continue\n        key, val = line.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if not key:\n            continue\n        try:\n            parsed_val = int(val)\n        except ValueError:\n            parsed_val = val\n        result[key] = parsed_val\n    return result", "error": null, "raw_item": {"task_id": "custom_parse_key_value_config", "prompt": "Write parse_key_value_config(text) that parses a configuration string with lines of the form 'key=value'. Ignore blank lines and lines starting with '#'. Return a dictionary with string keys and values converted to int if possible, else string. Return only the Python function code with no explanations.", "entry_point": "parse_key_value_config", "canonical_solution": "def parse_key_value_config(text: str) -> dict:\n    result = {}\n    for line in text.splitlines():\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        if '=' in line:\n            k,v = line.split('=',1)\n            v = v.strip()\n            if v.isdigit():\n                result[k.strip()] = int(v)\n            else:\n                result[k.strip()] = v\n    return result", "test": [{"input": ["a=1\nb=2\nc=hello"], "output": {"a": 1, "b": 2, "c": "hello"}}, {"input": ["#comment\nx=42\ny=text"], "output": {"x": 42, "y": "text"}}, {"input": [""], "output": {}}]}}
{"timestamp_utc": "2025-09-24T16:13:48.720739", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 52, "question": "Write pretty_print_matrix(matrix) that formats a 2D list of integers into a string where each row is space-separated and rows are separated by newlines. Columns should be aligned to the maximum width of the largest number. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 10.760069847106934, "response": "def pretty_print_matrix(matrix):\n    if not matrix:\n        return \"\"\n    width = max((len(str(x)) for row in matrix for x in row), default=0)\n    lines = []\n    for row in matrix:\n        if not row:\n            lines.append(\"\")\n        else:\n            lines.append(\" \".join(str(x).rjust(width) for x in row))\n    return \"\\n\".join(lines)", "error": null, "raw_item": {"task_id": "custom_pretty_print_matrix", "prompt": "Write pretty_print_matrix(matrix) that formats a 2D list of integers into a string where each row is space-separated and rows are separated by newlines. Columns should be aligned to the maximum width of the largest number. Return only the Python function code with no explanations.", "entry_point": "pretty_print_matrix", "canonical_solution": "def pretty_print_matrix(matrix: list[list[int]]) -> str:\n    if not matrix:\n        return ''\n    col_widths = [max(len(str(row[i])) for row in matrix) for i in range(len(matrix[0]))]\n    lines = []\n    for row in matrix:\n        line = ' '.join(str(val).rjust(col_widths[i]) for i,val in enumerate(row))\n        lines.append(line)\n    return '\\n'.join(lines)", "test": [{"input": [[[1, 20], [300, 4]]], "output": "  1 20\n300  4"}, {"input": [[[5]]], "output": "5"}, {"input": [[]], "output": ""}]}}
{"timestamp_utc": "2025-09-24T16:14:01.623752", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 53, "question": "Write unique_permutations(s) that returns all distinct permutations of string s in lexicographic order. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 11.900803804397583, "response": "def unique_permutations(s):\n    from collections import Counter\n    cnt = Counter(s)\n    chars = sorted(cnt.keys())\n    n = len(s)\n    res = []\n    def back(path):\n        if len(path) == n:\n            res.append(''.join(path))\n            return\n        for ch in chars:\n            if cnt[ch] > 0:\n                cnt[ch] -= 1\n                path.append(ch)\n                back(path)\n                path.pop()\n                cnt[ch] += 1\n    back([])\n    return res", "error": null, "raw_item": {"task_id": "custom_unique_permutations", "prompt": "Write unique_permutations(s) that returns all distinct permutations of string s in lexicographic order. Return only the Python function code with no explanations.", "entry_point": "unique_permutations", "canonical_solution": "def unique_permutations(s: str) -> list[str]:\n    from itertools import permutations\n    return sorted(set(''.join(p) for p in permutations(s)))", "test": [{"input": ["aab"], "output": ["aab", "aba", "baa"]}, {"input": ["abc"], "output": ["abc", "acb", "bac", "bca", "cab", "cba"]}, {"input": ["x"], "output": ["x"]}]}}
{"timestamp_utc": "2025-09-24T16:14:18.109820", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 54, "question": "Write format_prime_factors(n) that returns the prime factorization of integer n as a string in the form 'p1^a1 * p2^a2 ...'. If exponent is 1, omit the '^1'. Example: 60 → '2^2 * 3 * 5'. Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 15.484732866287231, "response": "def format_prime_factors(n):\n    if n == 0:\n        raise ValueError(\"Factorization of zero is undefined\")\n    sign = ''\n    if n < 0:\n        sign = '-'\n        n = -n\n    if n == 1:\n        return sign + '1'\n    import math\n    parts = []\n    cnt = 0\n    while n % 2 == 0:\n        n //= 2\n        cnt += 1\n    if cnt:\n        parts.append(f\"2^{cnt}\" if cnt > 1 else \"2\")\n    p = 3\n    while p * p <= n:\n        if n % p == 0:\n            cnt = 0\n            while n % p == 0:\n                n //= p\n                cnt += 1\n            parts.append(f\"{p}^{cnt}\" if cnt > 1 else str(p))\n        p += 2\n    if n > 1:\n        parts.append(str(n))\n    return sign + \" * \".join(parts)", "error": null, "raw_item": {"task_id": "custom_format_prime_factors", "prompt": "Write format_prime_factors(n) that returns the prime factorization of integer n as a string in the form 'p1^a1 * p2^a2 ...'. If exponent is 1, omit the '^1'. Example: 60 → '2^2 * 3 * 5'. Return only the Python function code with no explanations.", "entry_point": "format_prime_factors", "canonical_solution": "def format_prime_factors(n: int) -> str:\n    factors = []\n    d = 2\n    while d*d <= n:\n        count = 0\n        while n % d == 0:\n            n //= d\n            count += 1\n        if count:\n            factors.append(f\"{d}^{count}\" if count>1 else str(d))\n        d += 1\n    if n > 1:\n        factors.append(str(n))\n    return ' * '.join(factors)", "test": [{"input": [60], "output": "2^2 * 3 * 5"}, {"input": [13], "output": "13"}, {"input": [1024], "output": "2^10"}]}}
{"timestamp_utc": "2025-09-24T16:15:19.447651", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 55, "question": "Write validate_expression(expr) that checks if a string is a valid arithmetic expression containing only digits, +, -, *, /, parentheses, and spaces. Return True if valid, else False. Parentheses must be balanced and no invalid sequences allowed (e.g. '*/', '++', empty parentheses). Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 60.33618116378784, "response": "def validate_expression(expr):\n    expr = expr or \"\"\n    n = len(expr)\n    i = 0\n\n    def next_non_space(j):\n        while j < n and expr[j] == ' ':\n            j += 1\n        return j\n\n    tokens = []  # list of (type, value) where type in {'NUM','OP','LP','RP','UOP'}\n    prev_type = None\n\n    while i < n:\n        c = expr[i]\n        if c == ' ':\n            i += 1\n            continue\n        if c.isdigit():\n            j = i\n            while j < n and expr[j].isdigit():\n                j += 1\n            tokens.append(('NUM', expr[i:j]))\n            prev_type = 'NUM'\n            i = j\n            continue\n        if c in '+-':\n            # decide unary or binary\n            unary = prev_type is None or prev_type in ('OP', 'LP', 'UOP')\n            j = next_non_space(i + 1)\n            if unary:\n                if j < n and expr[j].isdigit():\n                    # read signed number\n                    k = j\n                    while k < n and expr[k].isdigit():\n                        k += 1\n                    tokens.append(('NUM', expr[i] + expr[j:k]))\n                    prev_type = 'NUM'\n                    i = k\n                    continue\n                elif j < n and expr[j] == '(':\n                    # unary operator before parenthesis\n                    tokens.append(('UOP', c))\n                    prev_type = 'UOP'\n                    i += 1\n                    continue\n                else:\n                    return False\n            else:\n                tokens.append(('OP', c))\n                prev_type = 'OP'\n                i += 1\n                continue\n        if c in '*/':\n            tokens.append(('OP', c))\n            prev_type = 'OP'\n            i += 1\n            continue\n        if c == '(':\n            tokens.append(('LP', c))\n            prev_type = 'LP'\n            i += 1\n            continue\n        if c == ')':\n            tokens.append(('RP', c))\n            prev_type = 'RP'\n            i += 1\n            continue\n        return False  # invalid character\n\n    if not tokens:\n        return False\n\n    # validate token sequence and parentheses\n    stack = []\n    last = None\n    for idx, (typ, val) in enumerate(tokens):\n        # parentheses balance & empty-paren checks\n        if typ == 'LP':\n            stack.append(idx)\n        elif typ == 'RP':\n            if not stack:\n                return False\n            open_idx = stack.pop()\n            # if immediate empty parentheses: nothing between LP and RP\n            if idx == open_idx + 1:\n                return False\n            # also disallow a UOP directly before RP (e.g. \"(-)\")\n            # find token right before this RP (skip spaces already removed)\n            prev_tok = tokens[idx - 1][0] if idx - 1 >= 0 else None\n            if prev_tok in ('LP', 'UOP'):\n                return False\n\n        # sequence rules\n        if typ == 'NUM':\n            # number can follow: start, OP, LP, UOP\n            if last is None or last in ('OP', 'LP', 'UOP'):\n                pass\n            else:\n                # cannot have number directly after NUM or RP\n                if last in ('NUM', 'RP'):\n                    # two numbers consecutive like \"3 4\" should be invalid\n                    return False\n                # other cases handled\n        elif typ == 'OP':\n            # binary op cannot be at start or after OP or after UOP or after LP\n            if last is None or last in ('OP', 'UOP', 'LP'):\n                return False\n        elif typ == 'LP':\n            # LP can appear at start or after OP or after LP or after UOP\n            if last is None or last in ('OP', 'LP', 'UOP'):\n                pass\n            else:\n                return False\n        elif typ == 'RP':\n            # RP cannot be at start or after OP or after UOP\n            if last is None or last in ('OP', 'UOP'):\n                return False\n        elif typ == 'UOP':\n            # UOP can appear at start or after OP or after LP, but cannot follow another UOP\n            if last is None or last in ('OP', 'LP'):\n                # allowed\n                # but if next token after UOP will be validated later\n                pass\n            else:\n                return False\n            # prevent consecutive UOPs like \"--(\"\n            if last == 'UOP':\n                return False\n        last = typ\n\n    # final token must be NUM or RP\n    if tokens[-1][0] not in ('NUM', 'RP'):\n        return False\n    if stack:\n        return False\n    return True", "error": null, "raw_item": {"task_id": "custom_validate_expression", "prompt": "Write validate_expression(expr) that checks if a string is a valid arithmetic expression containing only digits, +, -, *, /, parentheses, and spaces. Return True if valid, else False. Parentheses must be balanced and no invalid sequences allowed (e.g. '*/', '++', empty parentheses). Return only the Python function code with no explanations.", "entry_point": "validate_expression", "canonical_solution": "import re\ndef validate_expression(expr: str) -> bool:\n    expr = expr.strip()\n    if not expr:\n        return False\n    # invalid sequences\n    if re.search(r'[+*/-]{2,}', expr):\n        return False\n    if re.search(r'\\(\\)', expr):\n        return False\n    # parentheses balance\n    stack = []\n    for c in expr:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack:\n                return False\n            stack.pop()\n    if stack:\n        return False\n    # final safety: try eval\n    try:\n        eval(expr, {\"__builtins__\":None}, {})\n    except:\n        return False\n    return True", "test": [{"input": ["1+2*(3-4)"], "output": true}, {"input": ["(5+6"], "output": false}, {"input": ["1++2"], "output": false}, {"input": ["( )"], "output": false}, {"input": ["10/2-3"], "output": true}]}}
{"timestamp_utc": "2025-09-24T16:15:47.202552", "dataset_file": "MyFinalOwnBench.jsonl", "dataset_index": 56, "question": "Write parse_roman(s) that converts a valid Roman numeral string into an integer. Supports numerals up to 3999 (MMMCMXCIX). Return only the Python function code with no explanations.", "provider": "openai", "model": "gpt-5-mini", "region": null, "success": true, "response_time": 26.75272488594055, "response": "def parse_roman(s):\n    import re\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    s = s.strip().upper()\n    if not s:\n        raise ValueError(\"Empty Roman numeral\")\n    pattern = r'^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'\n    if not re.fullmatch(pattern, s):\n        raise ValueError(\"Invalid Roman numeral or out of range (1-3999)\")\n    vals = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    for i, ch in enumerate(s):\n        v = vals[ch]\n        if i + 1 < len(s) and vals[s[i + 1]] > v:\n            total -= v\n        else:\n            total += v\n    return total", "error": null, "raw_item": {"task_id": "custom_parse_roman", "prompt": "Write parse_roman(s) that converts a valid Roman numeral string into an integer. Supports numerals up to 3999 (MMMCMXCIX). Return only the Python function code with no explanations.", "entry_point": "parse_roman", "canonical_solution": "def parse_roman(s: str) -> int:\n    values = {\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000}\n    total = 0\n    i = 0\n    while i < len(s):\n        if i+1 < len(s) and values[s[i]] < values[s[i+1]]:\n            total += values[s[i+1]] - values[s[i]]\n            i += 2\n        else:\n            total += values[s[i]]\n            i += 1\n    return total", "test": [{"input": ["III"], "output": 3}, {"input": ["IX"], "output": 9}, {"input": ["LVIII"], "output": 58}, {"input": ["MCMXCIV"], "output": 1994}, {"input": ["MMMCMXCIX"], "output": 3999}]}}
