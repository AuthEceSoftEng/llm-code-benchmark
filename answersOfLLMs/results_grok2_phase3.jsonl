{"timestamp_utc": "2025-09-29T07:52:54.343937", "dataset_file": "testbench.jsonl", "dataset_index": 0, "question": "Detect if a directed graph (adjacency list) contains a cycle. Return True if there is a cycle, else False.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 17.519222736358643, "response": "```python\ndef has_cycle(graph):\n    visited = {}\n    def dfs(node):\n        if node in visited:\n            if visited[node] == 1:\n                return True\n            if visited[node] == 2:\n                return False\n        visited[node] = 1\n        for neighbor in graph.get(node, []):\n            if dfs(neighbor):\n                return True\n        visited[node] = 2\n        return False\n    all_nodes = set(graph.keys())\n    for neighbors in graph.values():\n        all_nodes.update(neighbors)\n    for node in all_nodes:\n        if node not in visited:\n            if dfs(node):\n                return True\n    return False\n```", "error": null, "raw_item": {"task_id": "CustomEval/graph_3", "prompt": "Detect if a directed graph (adjacency list) contains a cycle. Return True if there is a cycle, else False.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "has_cycle_directed", "canonical_solution": "def has_cycle_directed(graph):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    colors = {}\n    \n    def dfs(node):\n        if node in colors:\n            return colors[node] == GRAY\n        \n        colors[node] = GRAY\n        \n        for neighbor in graph.get(node, []):\n            if dfs(neighbor):\n                return True\n        \n        colors[node] = BLACK\n        return False\n    \n    for node in graph:\n        if node not in colors:\n            if dfs(node):\n                return True\n    \n    return False", "test": "def check(candidate):\n    assert candidate({'A': ['B'], 'B': ['C'], 'C': ['A']}) == True\n    assert candidate({'A': ['B'], 'B': [], 'C': []}) == False\n    assert candidate({1: [2], 2: [3], 3: []}) == False\n    assert candidate({'A': ['A']}) == True\n    assert candidate({}) == False"}}
{"timestamp_utc": "2025-09-29T07:53:18.097008", "dataset_file": "testbench.jsonl", "dataset_index": 1, "question": "Return a topological ordering of a directed acyclic graph (DAG) as a list using Kahn's algorithm. If the graph has a cycle, return an empty list.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 22.750672817230225, "response": "```python\nfrom collections import deque, defaultdict\n\ndef topological_sort(graph):\n    all_nodes = set(graph.keys())\n    for neighbors in graph.values():\n        all_nodes.update(neighbors)\n    \n    indegree = {node: 0 for node in all_nodes}\n    for neighbors in graph.values():\n        for nei in neighbors:\n            indegree[nei] += 1\n    \n    queue = deque([node for node in all_nodes if indegree[node] == 0])\n    order = []\n    \n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        if node in graph:\n            for nei in graph[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    queue.append(nei)\n    \n    if len(order) == len(all_nodes):\n        return order\n    else:\n        return []\n```", "error": null, "raw_item": {"task_id": "CustomEval/graph_4", "prompt": "Return a topological ordering of a directed acyclic graph (DAG) as a list using Kahn's algorithm. If the graph has a cycle, return an empty list.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "topo_sort", "canonical_solution": "from collections import deque\n\ndef topo_sort(graph):\n    # Get all nodes in the graph\n    all_nodes = set(graph.keys())\n    for neighbors in graph.values():\n        all_nodes.update(neighbors)\n    \n    # Calculate in-degrees\n    indegree = {node: 0 for node in all_nodes}\n    for node in graph:\n        for neighbor in graph[node]:\n            indegree[neighbor] += 1\n    \n    # Initialize queue with nodes having in-degree 0\n    queue = deque([node for node in all_nodes if indegree[node] == 0])\n    result = []\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        \n        for neighbor in graph.get(node, []):\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Return result only if all nodes are processed (no cycle)\n    return result if len(result) == len(all_nodes) else []", "test": "def check(candidate):\n    result1 = candidate({'A': ['C'], 'B': ['C'], 'C': []})\n    assert set(result1[:2]) == {'A', 'B'} and result1[2] == 'C'\n    \n    assert candidate({'A': ['B'], 'B': ['C'], 'C': []}) == ['A', 'B', 'C']\n    assert candidate({'A': ['B'], 'B': ['A']}) == []\n    assert candidate({}) == []\n    \n    result2 = candidate({1: [3], 2: [3], 3: [4], 4: []})\n    assert set(result2[:2]) == {1, 2} and result2[2:] == [3, 4]"}}
{"timestamp_utc": "2025-09-29T07:53:25.567316", "dataset_file": "testbench.jsonl", "dataset_index": 2, "question": "Remove duplicates from a list while preserving the original order. Only hashable elements will appear.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 6.468813180923462, "response": "```python\ndef remove_duplicates(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            result.append(item)\n            seen.add(item)\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_ordered_unique", "prompt": "Remove duplicates from a list while preserving the original order. Only hashable elements will appear.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "ordered_unique", "canonical_solution": "def ordered_unique(xs):\n    seen = set()\n    result = []\n    for x in xs:\n        if x not in seen:\n            seen.add(x)\n            result.append(x)\n    return result", "test": "def check(candidate):\n    assert candidate([1, 2, 2, 3, 1, 4]) == [1, 2, 3, 4]\n    assert candidate(['a', 'b', 'a', 'c', 'b']) == ['a', 'b', 'c']\n    assert candidate([]) == []\n    assert candidate([1, 1, 1]) == [1]\n    assert candidate([5]) == [5]"}}
{"timestamp_utc": "2025-09-29T07:53:34.988186", "dataset_file": "testbench.jsonl", "dataset_index": 3, "question": "Given a list of closed intervals [start, end] with start <= end, merge all overlapping intervals and return the merged list sorted by start.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 8.416812896728516, "response": "```python\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        if last[1] >= current[0]:\n            last[1] = max(last[1], current[1])\n        else:\n            merged.append(current)\n    return merged\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_merge_intervals_closed", "prompt": "Given a list of closed intervals [start, end] with start <= end, merge all overlapping intervals and return the merged list sorted by start.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "merge_intervals", "canonical_solution": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    \n    # Sort intervals by start time\n    sorted_intervals = sorted(intervals, key=lambda x: x[0])\n    merged = [list(sorted_intervals[0])]\n    \n    for start, end in sorted_intervals[1:]:\n        last_start, last_end = merged[-1]\n        \n        if start <= last_end:\n            # Overlapping intervals, merge them\n            merged[-1][1] = max(last_end, end)\n        else:\n            # Non-overlapping interval\n            merged.append([start, end])\n    \n    return merged", "test": "def check(candidate):\n    assert candidate([[1, 3], [2, 6], [8, 10], [15, 18]]) == [[1, 6], [8, 10], [15, 18]]\n    assert candidate([[1, 4], [4, 5]]) == [[1, 5]]\n    assert candidate([]) == []\n    assert candidate([[1, 1]]) == [[1, 1]]\n    assert candidate([[1, 4], [0, 4]]) == [[0, 4]]"}}
{"timestamp_utc": "2025-09-29T07:54:16.772929", "dataset_file": "testbench.jsonl", "dataset_index": 4, "question": "Parse a URL query string like \"a=1&b=2&b=3&c=\" into a dictionary. Keys with a single value map to that string, keys with repeated values map to a list of strings. Do not decode percent-encoding.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 40.782554149627686, "response": "```python\nimport collections\n\ndef parse_query_string(qs):\n    d = collections.defaultdict(list)\n    for pair in qs.split('&'):\n        if not pair:\n            continue\n        parts = pair.split('=', 1)\n        key = parts[0]\n        value = parts[1] if len(parts) == 2 else ''\n        d[key].append(value)\n    result = {}\n    for k, v in d.items():\n        if len(v) == 1:\n            result[k] = v[0]\n        else:\n            result[k] = v\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_parse_query", "prompt": "Parse a URL query string like \"a=1&b=2&b=3&c=\" into a dictionary. Keys with a single value map to that string, keys with repeated values map to a list of strings. Do not decode percent-encoding.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "parse_query", "canonical_solution": "def parse_query(qs):\n    if not qs:\n        return {}\n    \n    result = {}\n    for part in qs.split('&'):\n        if not part:\n            continue\n            \n        if '=' in part:\n            key, value = part.split('=', 1)\n        else:\n            key, value = part, ''\n        \n        if key in result:\n            if isinstance(result[key], list):\n                result[key].append(value)\n            else:\n                result[key] = [result[key], value]\n        else:\n            result[key] = value\n    \n    return result", "test": "def check(candidate):\n    assert candidate('a=1&b=2&b=3&c=') == {'a': '1', 'b': ['2', '3'], 'c': ''}\n    assert candidate('x=10') == {'x': '10'}\n    assert candidate('flag&y=7') == {'flag': '', 'y': '7'}\n    assert candidate('') == {}\n    assert candidate('a=1&a=2&a=3') == {'a': ['1', '2', '3']}"}}
{"timestamp_utc": "2025-09-29T07:54:35.316758", "dataset_file": "testbench.jsonl", "dataset_index": 5, "question": "Given a list of words and an integer k, return the k most frequent words sorted by descending frequency, then lexicographically for ties.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 17.541144847869873, "response": "```python\nimport collections\n\ndef topKFrequent(words, k):\n    count = collections.Counter(words)\n    candidates = list(count.keys())\n    candidates.sort(key=lambda w: (-count[w], w))\n    return candidates[:k]\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_topk_words", "prompt": "Given a list of words and an integer k, return the k most frequent words sorted by descending frequency, then lexicographically for ties.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "top_k_frequent", "canonical_solution": "def top_k_frequent(words, k):\n    freq = {}\n    for word in words:\n        freq[word] = freq.get(word, 0) + 1\n    \n    # Sort by frequency (descending) then lexicographically (ascending)\n    sorted_items = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n    \n    return [word for word, _ in sorted_items[:k]]", "test": "def check(candidate):\n    assert candidate(['i', 'love', 'leetcode', 'i', 'love', 'coding'], 2) == ['i', 'love']\n    assert candidate(['a', 'b', 'c'], 1) == ['a']\n    assert candidate(['a', 'a', 'b', 'b', 'c'], 3) == ['a', 'b', 'c']\n    assert candidate(['the', 'day', 'is', 'sunny', 'the', 'the', 'the', 'sunny', 'is', 'is'], 4) == ['the', 'is', 'sunny', 'day']"}}
{"timestamp_utc": "2025-09-29T07:56:17.345967", "dataset_file": "testbench.jsonl", "dataset_index": 6, "question": "Flatten a nested list up to a given depth d (d>=0). If d=0, return the list unchanged. Only lists need flattening; other types remain as-is.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 101.02645897865295, "response": "```python\ndef flatten(lst, depth):\n    if depth == 0:\n        return lst\n    result = []\n    for item in lst:\n        if isinstance(item, list):\n            result.extend(flatten(item, depth - 1))\n        else:\n            result.append(item)\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_flatten_depth", "prompt": "Flatten a nested list up to a given depth d (d>=0). If d=0, return the list unchanged. Only lists need flattening; other types remain as-is.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "flatten_depth", "canonical_solution": "def flatten_depth(lst, d):\n    if d <= 0:\n        return list(lst)\n    \n    result = []\n    for item in lst:\n        if isinstance(item, list):\n            result.extend(flatten_depth(item, d - 1))\n        else:\n            result.append(item)\n    \n    return result", "test": "def check(candidate):\n    assert candidate([1, [2, [3, [4]]]], 1) == [1, 2, [3, [4]]]\n    assert candidate([1, [2, [3, 4]], 5], 2) == [1, 2, 3, 4, 5]\n    assert candidate([], 3) == []\n    assert candidate([1, 2, 3], 0) == [1, 2, 3]\n    assert candidate([1, [2, 3]], 0) == [1, [2, 3]]"}}
{"timestamp_utc": "2025-09-29T07:56:26.047747", "dataset_file": "testbench.jsonl", "dataset_index": 7, "question": "Split a list into consecutive chunks of size n>0. The final chunk may be shorter. Return a list of chunks.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 7.696637868881226, "response": "```python\ndef chunk_list(lst, n):\n    result = []\n    for i in range(0, len(lst), n):\n        result.append(lst[i:i + n])\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_chunk", "prompt": "Split a list into consecutive chunks of size n>0. The final chunk may be shorter. Return a list of chunks.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "chunk", "canonical_solution": "def chunk(lst, n):\n    if n <= 0:\n        raise ValueError('n must be > 0')\n    return [lst[i:i + n] for i in range(0, len(lst), n)]", "test": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5], 2) == [[1, 2], [3, 4], [5]]\n    assert candidate([1, 2, 3], 3) == [[1, 2, 3]]\n    assert candidate([], 1) == []\n    assert candidate([1, 2, 3, 4, 5, 6], 2) == [[1, 2], [3, 4], [5, 6]]\n    \n    try:\n        candidate([1, 2, 3], 0)\n        assert False, 'Should raise ValueError'\n    except ValueError:\n        pass"}}
{"timestamp_utc": "2025-09-29T07:56:38.547293", "dataset_file": "testbench.jsonl", "dataset_index": 8, "question": "Convert a Roman numeral (I,V,X,L,C,D,M) to integer. Assume a valid numeral using standard subtractive notation.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 11.497452974319458, "response": "```python\ndef roman_to_int(s):\n    roman = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    total = 0\n    for i in range(len(s)):\n        if i < len(s) - 1 and roman[s[i]] < roman[s[i + 1]]:\n            total -= roman[s[i]]\n        else:\n            total += roman[s[i]]\n    return total\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_roman_to_int", "prompt": "Convert a Roman numeral (I,V,X,L,C,D,M) to integer. Assume a valid numeral using standard subtractive notation.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "roman_to_int", "canonical_solution": "def roman_to_int(s):\n    values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    i = 0\n    \n    while i < len(s):\n        current_val = values[s[i]]\n        \n        if i + 1 < len(s) and values[s[i + 1]] > current_val:\n            # Subtractive case (e.g., IV, IX, XL, etc.)\n            total += values[s[i + 1]] - current_val\n            i += 2\n        else:\n            # Regular case\n            total += current_val\n            i += 1\n    \n    return total", "test": "def check(candidate):\n    assert candidate('III') == 3\n    assert candidate('IV') == 4\n    assert candidate('MCMXCIV') == 1994\n    assert candidate('IX') == 9\n    assert candidate('LVIII') == 58\n    assert candidate('CD') == 400\n    assert candidate('CM') == 900"}}
{"timestamp_utc": "2025-09-29T07:59:15.176588", "dataset_file": "testbench.jsonl", "dataset_index": 9, "question": "Normalize a Unix-style path by resolving '.' and '..' components and removing redundant slashes. Do not access the filesystem. Keep leading '/' for absolute paths.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 155.62707495689392, "response": "```python\ndef normalize(path):\n    if not path:\n        return '.'\n    is_absolute = path.startswith('/')\n    parts = path.split('/')\n    stack = []\n    for part in parts:\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            if stack and stack[-1] != '..':\n                stack.pop()\n            elif not is_absolute:\n                stack.append('..')\n        else:\n            stack.append(part)\n    if is_absolute:\n        return '/' + '/'.join(stack)\n    else:\n        result = '/'.join(stack)\n        return result if result else '.'\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_normalize_path", "prompt": "Normalize a Unix-style path by resolving '.' and '..' components and removing redundant slashes. Do not access the filesystem. Keep leading '/' for absolute paths.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "normalize_path", "canonical_solution": "def normalize_path(path):\n    parts = []\n    is_absolute = path.startswith('/')\n    \n    for component in path.split('/'):\n        if component == '' or component == '.':\n            continue\n        elif component == '..':\n            if parts and parts[-1] != '..':\n                parts.pop()\n            elif not is_absolute:\n                parts.append('..')\n        else:\n            parts.append(component)\n    \n    result = '/'.join(parts)\n    \n    if is_absolute:\n        result = '/' + result\n    elif not result:\n        result = '.'\n    \n    return result", "test": "def check(candidate):\n    assert candidate('/a//b/./c/../d/') == '/a/b/d'\n    assert candidate('a/b/../../c') == 'c'\n    assert candidate('./././') == '.'\n    assert candidate('/') == '/'\n    assert candidate('../../a/b') == '../../a/b'\n    assert candidate('/a/b/../..') == '/'\n    assert candidate('a/b/c/../../..') == '.'}"}}
{"timestamp_utc": "2025-09-29T08:02:03.975837", "dataset_file": "testbench.jsonl", "dataset_index": 10, "question": "Split a CSV line by commas, respecting double quotes. Quotes may enclose commas, and doubled quotes \"\" represent a literal quote inside a quoted field. Return a list of fields.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 167.7960467338562, "response": "```python\ndef parse_csv_line(line):\n    fields = []\n    i = 0\n    while i < len(line):\n        current = []\n        if i < len(line) and line[i] == '\"':\n            i += 1\n            while i < len(line):\n                if line[i] == '\"':\n                    if i + 1 < len(line) and line[i + 1] == '\"':\n                        current.append('\"')\n                        i += 1\n                    else:\n                        i += 1\n                        break\n                else:\n                    current.append(line[i])\n                i += 1\n        else:\n            while i < len(line) and line[i] != ',':\n                current.append(line[i])\n                i += 1\n        fields.append(''.join(current))\n        if i < len(line) and line[i] == ',':\n            i += 1\n    if (i == len(line) and line and line[-1] == ',') or len(fields) == 0:\n        fields.append('')\n    return fields\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_split_csv", "prompt": "Split a CSV line by commas, respecting double quotes. Quotes may enclose commas, and doubled quotes \"\" represent a literal quote inside a quoted field. Return a list of fields.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "split_csv", "canonical_solution": "def split_csv(line):\n    result = []\n    field = []\n    i = 0\n    in_quotes = False\n    \n    while i < len(line):\n        char = line[i]\n        \n        if in_quotes:\n            if char == '\"':\n                if i + 1 < len(line) and line[i + 1] == '\"':\n                    # Escaped quote\n                    field.append('\"')\n                    i += 2\n                    continue\n                else:\n                    # End of quoted field\n                    in_quotes = False\n            else:\n                field.append(char)\n            i += 1\n        else:\n            if char == ',':\n                result.append(''.join(field))\n                field = []\n                i += 1\n            elif char == '\"':\n                in_quotes = True\n                i += 1\n            else:\n                field.append(char)\n                i += 1\n    \n    result.append(''.join(field))\n    return result", "test": "def check(candidate):\n    assert candidate('a,b,c') == ['a', 'b', 'c']\n    assert candidate('\"a,1\",b,\"c\"') == ['a,1', 'b', 'c']\n    assert candidate('a,\"b, c\",d') == ['a', 'b, c', 'd']\n    assert candidate('\"hello \"\"world\"\"\",test') == ['hello \"world\"', 'test']\n    assert candidate('') == ['']"}}
{"timestamp_utc": "2025-09-29T08:02:21.483297", "dataset_file": "testbench.jsonl", "dataset_index": 11, "question": "Check if a string of brackets is balanced. Supports (), {}, []. Return True if balanced, False otherwise.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 16.504645824432373, "response": "```python\ndef is_balanced(s: str) -> bool:\n    stack = []\n    matching = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in '({[':\n            stack.append(char)\n        elif char in matching:\n            if not stack or stack.pop() != matching[char]:\n                return False\n    return len(stack) == 0\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_is_balanced", "prompt": "Check if a string of brackets is balanced. Supports (), {}, []. Return True if balanced, False otherwise.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "is_balanced", "canonical_solution": "def is_balanced(s):\n    pairs = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    \n    for char in s:\n        if char in '([{':\n            stack.append(char)\n        elif char in pairs:\n            if not stack or stack.pop() != pairs[char]:\n                return False\n    \n    return len(stack) == 0", "test": "def check(candidate):\n    assert candidate('()[]{}') == True\n    assert candidate('(]') == False\n    assert candidate('([{}])') == True\n    assert candidate('') == True\n    assert candidate('((()))') == True\n    assert candidate('([)]') == False\n    assert candidate('{[()]}') == True"}}
{"timestamp_utc": "2025-09-29T08:03:04.390213", "dataset_file": "testbench.jsonl", "dataset_index": 12, "question": "Validate if a string is a valid email address (simple version). A valid email has the form name@domain.tld where name and domain contain letters, digits, dots, underscores, and hyphens, and tld is 2-6 letters.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 41.90239119529724, "response": "```python\nimport re\n\ndef is_valid_email(s):\n    pattern = r'^[a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\\.[a-zA-Z]{2,6}$'\n    return bool(re.match(pattern, s))\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_regex_email", "prompt": "Validate if a string is a valid email address (simple version). A valid email has the form name@domain.tld where name and domain contain letters, digits, dots, underscores, and hyphens, and tld is 2-6 letters.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "is_valid_email", "canonical_solution": "import re\n\ndef is_valid_email(email):\n    pattern = r'^[A-Za-z0-9._-]+@[A-Za-z0-9._-]+\\.[A-Za-z]{2,6}$'\n    return bool(re.match(pattern, email))", "test": "def check(candidate):\n    assert candidate('test@example.com') == True\n    assert candidate('bad@domain') == False\n    assert candidate('hello@world.org') == True\n    assert candidate('user.name@sub.domain.co') == True\n    assert candidate('test_123@example-site.info') == True\n    assert candidate('@domain.com') == False\n    assert candidate('test@.com') == False\n    assert candidate('test@domain.') == False"}}
{"timestamp_utc": "2025-09-29T08:03:39.635119", "dataset_file": "testbench.jsonl", "dataset_index": 13, "question": "Flatten a nested JSON/dict into a single-level dict with dot-separated keys.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 34.24348187446594, "response": "```python\ndef flatten(nested, prefix='', result=None):\n    if result is None:\n        result = {}\n    if isinstance(nested, dict):\n        for key, value in nested.items():\n            flatten(value, f'{prefix}{key}.', result)\n    elif isinstance(nested, (list, tuple)):\n        for i, value in enumerate(nested):\n            flatten(value, f'{prefix}{i}.', result)\n    else:\n        result[prefix[:-1]] = nested\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_json_flatten", "prompt": "Flatten a nested JSON/dict into a single-level dict with dot-separated keys.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "flatten_json", "canonical_solution": "def flatten_json(data, parent_key='', separator='.'):\n    items = {}\n    \n    if not isinstance(data, dict):\n        return {parent_key: data} if parent_key else {}\n    \n    for key, value in data.items():\n        new_key = parent_key + separator + key if parent_key else key\n        \n        if isinstance(value, dict):\n            items.update(flatten_json(value, new_key, separator))\n        else:\n            items[new_key] = value\n    \n    return items", "test": "def check(candidate):\n    assert candidate({'a': 1, 'b': {'c': 2, 'd': 3}}) == {'a': 1, 'b.c': 2, 'b.d': 3}\n    assert candidate({'x': {'y': {'z': 10}}}) == {'x.y.z': 10}\n    assert candidate({}) == {}\n    assert candidate({'a': 1}) == {'a': 1}\n    assert candidate({'a': {'b': {'c': {'d': 1}}}}) == {'a.b.c.d': 1}"}}
{"timestamp_utc": "2025-09-29T08:03:47.804274", "dataset_file": "testbench.jsonl", "dataset_index": 14, "question": "Given two date strings in format YYYY-MM-DD, return the absolute difference in days.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 7.16359806060791, "response": "```python\nfrom datetime import datetime\n\ndef date_difference(date1, date2):\n    d1 = datetime.strptime(date1, \"%Y-%m-%d\").date()\n    d2 = datetime.strptime(date2, \"%Y-%m-%d\").date()\n    delta = d1 - d2\n    return abs(delta.days)\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_datetime_diff", "prompt": "Given two date strings in format YYYY-MM-DD, return the absolute difference in days.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "days_diff", "canonical_solution": "from datetime import datetime\n\ndef days_diff(date1, date2):\n    date_format = '%Y-%m-%d'\n    d1 = datetime.strptime(date1, date_format)\n    d2 = datetime.strptime(date2, date_format)\n    return abs((d1 - d2).days)", "test": "def check(candidate):\n    assert candidate('2023-01-01', '2023-01-10') == 9\n    assert candidate('2020-02-28', '2020-03-01') == 2\n    assert candidate('2023-12-31', '2024-01-01') == 1\n    assert candidate('2023-01-01', '2023-01-01') == 0\n    assert candidate('2024-02-29', '2024-03-01') == 1"}}
{"timestamp_utc": "2025-09-29T08:03:59.988887", "dataset_file": "testbench.jsonl", "dataset_index": 15, "question": "Rotate an n x n matrix 90 degrees clockwise in-place. Return the modified matrix.\n\nPlease return only the Python function code, without any explanations or additional text.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 11.181288003921509, "response": "```python\ndef rotate(matrix):\n    n = len(matrix)\n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # Reverse each row\n    for i in range(n):\n        matrix[i].reverse()\n    return matrix\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_matrix_rotate", "prompt": "Rotate an n x n matrix 90 degrees clockwise in-place. Return the modified matrix.\n\nPlease return only the Python function code, without any explanations or additional text.", "entry_point": "rotate_matrix", "canonical_solution": "def rotate_matrix(matrix):\n    n = len(matrix)\n    \n    # Transpose the matrix\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Reverse each row\n    for row in matrix:\n        row.reverse()\n    \n    return matrix", "test": "def check(candidate):\n    assert candidate([[1, 2], [3, 4]]) == [[3, 1], [4, 2]]\n    assert candidate([[1]]) == [[1]]\n    \n    matrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    expected1 = [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    assert candidate(matrix1) == expected1\n    \n    matrix2 = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]\n    expected2 = [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]\n    assert candidate(matrix2) == expected2"}}
{"timestamp_utc": "2025-09-29T08:04:14.014012", "dataset_file": "testbench.jsonl", "dataset_index": 16, "question": "Implement a simple LRU (least recently used) cache class with get(key) and put(key,value) methods. Capacity is fixed; evict least recently used item on overflow. Return only the Python function/class code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 13.021239995956421, "response": "```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_lru_cache", "prompt": "Implement a simple LRU (least recently used) cache class with get(key) and put(key,value) methods. Capacity is fixed; evict least recently used item on overflow. Return only the Python function/class code, no explanations or test cases.", "entry_point": "LRUCache", "canonical_solution": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cap = capacity\n        self.od = OrderedDict()\n    def get(self, key):\n        if key not in self.od:\n            return -1\n        val = self.od.pop(key)\n        self.od[key] = val\n        return val\n    def put(self, key, val):\n        if key in self.od:\n            self.od.pop(key)\n        elif len(self.od) >= self.cap:\n            self.od.popitem(last=False)\n        self.od[key] = val", "test": [{"input": "[('put',1,1),('put',2,2),('get',1),('put',3,3),('get',2)]", "output": "[None,None,1,None,-1]"}]}}
{"timestamp_utc": "2025-09-29T08:06:13.379907", "dataset_file": "testbench.jsonl", "dataset_index": 17, "question": "Implement word wrap: given a string and max width, break into lines not exceeding width, breaking at spaces if possible. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 118.359060049057, "response": "```python\ndef word_wrap(string, max_width):\n    words = string.split()\n    lines = []\n    current = []\n    current_length = 0\n    for word in words:\n        space = 1 if current else 0\n        if current_length + space + len(word) > max_width:\n            if current:\n                lines.append(' '.join(current))\n                current = []\n                current_length = 0\n            pos = 0\n            while pos < len(word):\n                chunk_len = min(len(word) - pos, max_width)\n                lines.append(word[pos:pos + chunk_len])\n                pos += chunk_len\n            continue\n        current.append(word)\n        current_length += space + len(word)\n    if current:\n        lines.append(' '.join(current))\n    return '\\n'.join(lines)\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_word_wrap", "prompt": "Implement word wrap: given a string and max width, break into lines not exceeding width, breaking at spaces if possible. Return only the Python function code, no explanations or test cases.", "entry_point": "word_wrap", "canonical_solution": "def word_wrap(s, width):\n    words = s.split()\n    lines = []\n    cur = []\n    cur_len = 0\n    for w in words:\n        if cur_len + len(w) + (1 if cur else 0) <= width:\n            cur.append(w)\n            cur_len += len(w) + (1 if cur else 0)\n        else:\n            lines.append(' '.join(cur))\n            cur = [w]\n            cur_len = len(w)\n    if cur:\n        lines.append(' '.join(cur))\n    return lines", "test": [{"input": "\"This is a test of wrapping\", 7", "output": "['This is','a test','of','wrapping']"}]}}
{"timestamp_utc": "2025-09-29T08:06:21.505836", "dataset_file": "testbench.jsonl", "dataset_index": 18, "question": "Parse a CSV header and one row into a dictionary mapping column names to values. Assume no quotes or commas inside values. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 7.118407249450684, "response": "```python\ndef parse_csv_row(header, row):\n    columns = header.split(',')\n    values = row.split(',')\n    return dict(zip(columns, values))\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_csv_to_dict", "prompt": "Parse a CSV header and one row into a dictionary mapping column names to values. Assume no quotes or commas inside values. Return only the Python function code, no explanations or test cases.", "entry_point": "csv_to_dict", "canonical_solution": "def csv_to_dict(header, row):\n    cols = header.split(',')\n    vals = row.split(',')\n    return dict(zip(cols, vals))", "test": [{"input": "\"a,b,c\", \"1,2,3\"", "output": "{'a':'1','b':'2','c':'3'}"}]}}
{"timestamp_utc": "2025-09-29T08:06:40.447306", "dataset_file": "testbench.jsonl", "dataset_index": 19, "question": "Generate the first n rows of Pascal's Triangle as a list of lists. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 17.93868613243103, "response": "```python\ndef pascals_triangle(n):\n    if n == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, n):\n        row = [1]\n        for j in range(1, i):\n            row.append(triangle[-1][j-1] + triangle[-1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_pascal_triangle", "prompt": "Generate the first n rows of Pascal's Triangle as a list of lists. Return only the Python function code, no explanations or test cases.", "entry_point": "pascal_triangle", "canonical_solution": "def pascal_triangle(n):\n    res = []\n    for i in range(n):\n        row = [1]*(i+1)\n        for j in range(1,i):\n            row[j] = res[i-1][j-1] + res[i-1][j]\n        res.append(row)\n    return res", "test": [{"input": "5", "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"}]}}
{"timestamp_utc": "2025-09-29T08:06:50.147061", "dataset_file": "testbench.jsonl", "dataset_index": 20, "question": "Convert an integer 1 <= n <= 3999 to Roman numeral string. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 8.696329116821289, "response": "```python\ndef int_to_roman(n):\n    roman_numerals = [\n        (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n        (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n        (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')\n    ]\n    result = ''\n    for value, symbol in roman_numerals:\n        while n >= value:\n            result += symbol\n            n -= value\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_int_to_roman", "prompt": "Convert an integer 1 <= n <= 3999 to Roman numeral string. Return only the Python function code, no explanations or test cases.", "entry_point": "int_to_roman", "canonical_solution": "def int_to_roman(num):\n    vals = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n    syms = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\n    res = []\n    for v,s in zip(vals,syms):\n        while num >= v:\n            res.append(s)\n            num -= v\n    return ''.join(res)", "test": [{"input": "3", "output": "\"III\""}, {"input": "58", "output": "\"LVIII\""}, {"input": "1994", "output": "\"MCMXCIV\""}]}}
{"timestamp_utc": "2025-09-29T08:07:03.694913", "dataset_file": "testbench.jsonl", "dataset_index": 21, "question": "Implement the Sieve of Eratosthenes: given n, return all primes <= n. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 12.545477151870728, "response": "```python\ndef sieve_of_eratosthenes(n):\n    if n < 2:\n        return []\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n+1, i):\n                is_prime[j] = False\n    return [i for i in range(2, n+1) if is_prime[i]]\n```", "error": null, "raw_item": {"task_id": "CustomEval/so_prime_sieve", "prompt": "Implement the Sieve of Eratosthenes: given n, return all primes <= n. Return only the Python function code, no explanations or test cases.", "entry_point": "sieve_primes", "canonical_solution": "def sieve_primes(n):\n    if n < 2:\n        return []\n    sieve = [True]*(n+1)\n    sieve[0]=sieve[1]=False\n    for i in range(2,int(n**0.5)+1):\n        if sieve[i]:\n            for j in range(i*i,n+1,i):\n                sieve[j]=False\n    return [i for i in range(2,n+1) if sieve[i]]", "test": [{"input": "10", "output": "[2,3,5,7]"}, {"input": "1", "output": "[]"}]}}
{"timestamp_utc": "2025-09-29T08:08:07.385661", "dataset_file": "testbench.jsonl", "dataset_index": 22, "question": ".env parser: Given a string with .env file contents, parse KEY=VALUE pairs. Ignore blank lines and lines starting with '#'. Trim surrounding spaces around keys and values. Values may be quoted with single or double quotes; if quoted, unquote without interpreting escapes. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 62.68907809257507, "response": "```python\ndef parse_env(content: str) -> dict[str, str]:\n    env = {}\n    for line in content.splitlines():\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        if '=' not in line:\n            continue\n        key, value = line.split('=', 1)\n        key = key.strip()\n        value = value.strip()\n        if value and (value[0] == value[-1]) and value[0] in (\"'\", '\"'):\n            value = value[1:-1]\n        env[key] = value\n    return env\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_env_parse", "prompt": ".env parser: Given a string with .env file contents, parse KEY=VALUE pairs. Ignore blank lines and lines starting with '#'. Trim surrounding spaces around keys and values. Values may be quoted with single or double quotes; if quoted, unquote without interpreting escapes. Return only the Python function code, no explanations or test cases.", "entry_point": "parse_env", "canonical_solution": "def parse_env(text):\n    def unquote(v):\n        v=v.strip()\n        if len(v)>=2 and ((v[0]==v[-1]==\"'\") or (v[0]==v[-1]=='\"')):\n            return v[1:-1]\n        return v\n    out={}\n    for line in text.splitlines():\n        line=line.strip()\n        if not line or line.startswith('#'):\n            continue\n        if '=' not in line:\n            continue\n        k,v=line.split('=',1)\n        k=k.strip()\n        v=unquote(v)\n        out[k]=v\n    return out", "test": [{"input": "\"\"\"\n# comment\nUSER = 'alice'\nPORT=8080\nDEBUG = true\nEMPTY=\n\"\"\"", "output": "{'USER':'alice','PORT':'8080','DEBUG':'true','EMPTY':''}"}, {"input": "\"KEY=value\\nNAME=Bob\\n#X=1\"", "output": "{'KEY':'value','NAME':'Bob'}"}]}}
{"timestamp_utc": "2025-09-29T08:09:50.915137", "dataset_file": "testbench.jsonl", "dataset_index": 23, "question": "Compare two semantic version strings MAJOR.MINOR.PATCH optionally with a prerelease suffix after '-'. Return 1 if v1>v2, -1 if v1<v2, else 0. Numeric parts compared numerically; a release without prerelease is greater than the same version with prerelease. Prerelease strings are compared lexicographically if needed. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 102.5254340171814, "response": "```python\ndef compare_versions(v1, v2):\n    def parse(version):\n        if '-' in version:\n            numeric, pre = version.split('-', 1)\n        else:\n            numeric = version\n            pre = None\n        major, minor, patch = map(int, numeric.split('.'))\n        return (major, minor, patch), pre\n\n    def compare_pre(pre1, pre2):\n        parts1 = pre1.split('.')\n        parts2 = pre2.split('.')\n        min_len = min(len(parts1), len(parts2))\n        for i in range(min_len):\n            p1 = parts1[i]\n            p2 = parts2[i]\n            if p1 == p2:\n                continue\n            isnum1 = p1.isdigit()\n            isnum2 = p2.isdigit()\n            if isnum1 and isnum2:\n                n1 = int(p1)\n                n2 = int(p2)\n                if n1 > n2:\n                    return 1\n                if n1 < n2:\n                    return -1\n                return 0\n            elif isnum1:\n                return -1\n            elif isnum2:\n                return 1\n            else:\n                if p1 > p2:\n                    return 1\n                if p1 < p2:\n                    return -1\n                return 0\n        if len(parts1) > len(parts2):\n            return 1\n        if len(parts1) < len(parts2):\n            return -1\n        return 0\n\n    num1, pre1 = parse(v1)\n    num2, pre2 = parse(v2)\n    if num1 > num2:\n        return 1\n    if num1 < num2:\n        return -1\n    if pre1 is None and pre2 is None:\n        return 0\n    if pre1 is None:\n        return 1\n    if pre2 is None:\n        return -1\n    return compare_pre(pre1, pre2)\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_semver_compare", "prompt": "Compare two semantic version strings MAJOR.MINOR.PATCH optionally with a prerelease suffix after '-'. Return 1 if v1>v2, -1 if v1<v2, else 0. Numeric parts compared numerically; a release without prerelease is greater than the same version with prerelease. Prerelease strings are compared lexicographically if needed. Return only the Python function code, no explanations or test cases.", "entry_point": "semver_cmp", "canonical_solution": "def semver_cmp(v1, v2):\n    def split(v):\n        core, *pre = v.split('-',1)\n        a=list(map(int, core.split('.')))\n        while len(a)<3: a.append(0)\n        p=pre[0] if pre else None\n        return a,p\n    a1,p1=split(v1); a2,p2=split(v2)\n    if a1!=a2:\n        return 1 if a1>a2 else -1\n    if p1==p2:\n        return 0\n    if p1 is None: return 1\n    if p2 is None: return -1\n    return (1 if p1>p2 else -1) if p1!=p2 else 0", "test": [{"input": "\"1.2.3\",\"1.2.3\"", "output": "0"}, {"input": "\"1.2.3\",\"1.2.3-alpha\"", "output": "1"}, {"input": "\"1.10.0\",\"1.2.99\"", "output": "1"}, {"input": "\"2.0.0-alpha\",\"2.0.0-beta\"", "output": "-1"}]}}
{"timestamp_utc": "2025-09-29T08:11:22.760287", "dataset_file": "testbench.jsonl", "dataset_index": 24, "question": "Extract Markdown headings from text. Return a list of tuples (level, title) for lines starting with 1..6 '#' followed by a space. Do not strip inline hashes inside the title. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 90.84186005592346, "response": "```python\nimport re\n\ndef extract_headings(text):\n    headings = []\n    for line in text.splitlines():\n        match = re.match(r'^(#{1,6}) +(.*)$', line)\n        if match:\n            level = len(match.group(1))\n            title = match.group(2)\n            headings.append((level, title))\n    return headings\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_markdown_toc", "prompt": "Extract Markdown headings from text. Return a list of tuples (level, title) for lines starting with 1..6 '#' followed by a space. Do not strip inline hashes inside the title. Return only the Python function code, no explanations or test cases.", "entry_point": "extract_headings", "canonical_solution": "def extract_headings(md):\n    out=[]\n    for line in md.splitlines():\n        i=0\n        while i < len(line) and i<6 and line[i]=='#':\n            i+=1\n        if i and i<=6 and len(line)>i and line[i]==' ':\n            out.append((i, line[i+1:]))\n    return out", "test": [{"input": "\"# Title\\ntext\\n## Section 1\\n### Sub ## part\\n####### not heading\"", "output": "[(1,'Title'),(2,'Section 1'),(3,'Sub ## part')]"}, {"input": "\"no headings\"", "output": "[]"}]}}
{"timestamp_utc": "2025-09-29T08:15:24.493452", "dataset_file": "testbench.jsonl", "dataset_index": 25, "question": "Implement a simple .gitignore matcher. Given a path and a list of glob patterns, return True if any pattern matches the path. Use Unix-style matching; treat patterns as matching anywhere (no directory anchoring). Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 240.72795486450195, "response": "```python\nimport re\n\ndef glob_part_to_regex(part):\n    res = []\n    for c in part:\n        if c == '*':\n            res.append('[^/]*')\n        elif c == '?':\n            res.append('[^/]')\n        else:\n            res.append(re.escape(c))\n    return ''.join(res)\n\ndef is_ignored(path, patterns):\n    for pattern in patterns:\n        pattern = pattern.lstrip('/')\n        if not pattern:\n            continue\n        parts = pattern.split('/')\n        regex_parts = []\n        for p in parts:\n            if p == '**':\n                regex_parts.append('(?:[^/]+/)*')\n            else:\n                regex_parts.append(glob_part_to_regex(p))\n        regex_str = '^(?:[^/]+/)*' + '/'.join(regex_parts) + '$'\n        if re.match(regex_str, path):\n            return True\n    return False\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_gitignore_match", "prompt": "Implement a simple .gitignore matcher. Given a path and a list of glob patterns, return True if any pattern matches the path. Use Unix-style matching; treat patterns as matching anywhere (no directory anchoring). Return only the Python function code, no explanations or test cases.", "entry_point": "is_ignored", "canonical_solution": "import fnmatch\n\ndef is_ignored(path, patterns):\n    for pat in patterns:\n        if fnmatch.fnmatch(path, pat):\n            return True\n    return False", "test": [{"input": "\"src/main.py\", ['*.py']", "output": "True"}, {"input": "\"build/output.bin\", ['build/*','*.log']", "output": "True"}, {"input": "\"docs/readme.md\", ['*.rst']", "output": "False"}]}}
{"timestamp_utc": "2025-09-29T08:15:35.951889", "dataset_file": "testbench.jsonl", "dataset_index": 26, "question": "Join a base URL and a relative path like browsers do. Use Python's standard behavior to resolve '..' and absolute paths. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 10.455626010894775, "response": "```python\nimport urllib.parse\n\ndef join_url(base, relative):\n    return urllib.parse.urljoin(base, relative)\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_url_join", "prompt": "Join a base URL and a relative path like browsers do. Use Python's standard behavior to resolve '..' and absolute paths. Return only the Python function code, no explanations or test cases.", "entry_point": "url_join", "canonical_solution": "from urllib.parse import urljoin\n\ndef url_join(base, path):\n    return urljoin(base, path)", "test": [{"input": "\"https://example.com/a/b/\",\"c\"", "output": "\"https://example.com/a/b/c\""}, {"input": "\"https://example.com/a/b/\",\"/x/y\"", "output": "\"https://example.com/x/y\""}, {"input": "\"https://example.com/a/b\",\"../c\"", "output": "\"https://example.com/c\""}]}}
{"timestamp_utc": "2025-09-29T08:18:08.353473", "dataset_file": "testbench.jsonl", "dataset_index": 27, "question": "Minify JSON-with-comments: remove // line comments and /* ... */ block comments, then strip whitespace around the result. Do not alter content inside string literals (double-quoted). Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 151.39876914024353, "response": "```python\ndef minify_json(s: str) -> str:\n    result = []\n    i = 0\n    n = len(s)\n    while i < n:\n        if s[i] == '\"':\n            result.append('\"')\n            i += 1\n            while i < n:\n                if s[i] == '\\\\':\n                    result.append('\\\\')\n                    i += 1\n                    if i < n:\n                        result.append(s[i])\n                        i += 1\n                    continue\n                if s[i] == '\"':\n                    result.append('\"')\n                    i += 1\n                    break\n                result.append(s[i])\n                i += 1\n            continue\n        elif s[i] == '/' and i + 1 < n:\n            if s[i + 1] == '/':\n                i += 2\n                while i < n and s[i] != '\\n':\n                    i += 1\n                if i < n:\n                    i += 1\n                continue\n            elif s[i + 1] == '*':\n                i += 2\n                while i < n:\n                    if s[i] == '*' and i + 1 < n and s[i + 1] == '/':\n                        i += 2\n                        break\n                    i += 1\n                continue\n        elif not s[i].isspace():\n            result.append(s[i])\n            i += 1\n        else:\n            i += 1\n    return ''.join(result)\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_json_minify", "prompt": "Minify JSON-with-comments: remove // line comments and /* ... */ block comments, then strip whitespace around the result. Do not alter content inside string literals (double-quoted). Return only the Python function code, no explanations or test cases.", "entry_point": "json_minify", "canonical_solution": "def json_minify(s):\n    out=[]; i=0; n=len(s); in_str=False\n    while i<n:\n        ch=s[i]\n        if in_str:\n            out.append(ch)\n            if ch=='\\\\':\n                if i+1<n: out.append(s[i+1]); i+=2; continue\n            if ch=='\"': in_str=False\n            i+=1; continue\n        if ch=='\"':\n            in_str=True; out.append(ch); i+=1; continue\n        if ch=='/' and i+1<n and s[i+1]=='/':\n            i+=2\n            while i<n and s[i]!='\\n': i+=1\n            continue\n        if ch=='/' and i+1<n and s[i+1]=='*':\n            i+=2\n            while i+1<n and not (s[i]=='*' and s[i+1]=='/'): i+=1\n            i+=2; continue\n        out.append(ch); i+=1\n    return ''.join(out).strip()", "test": [{"input": "\"{\\n  // comment\\n  \\\"a\\\": 1, /* block */ \\n  \\\"b\\\": \\\"/not comment/* ok */\\\"\\n}\"", "output": "\"{\\n  \\n  \\\"a\\\": 1,  \\n  \\\"b\\\": \\\"/not comment/* ok */\\\"\\n}\""}]}}
{"timestamp_utc": "2025-09-29T08:18:27.117943", "dataset_file": "testbench.jsonl", "dataset_index": 28, "question": "Given a list of file paths, remove duplicates case-insensitively (Windows-style), preserving the first occurrence order. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 17.75913691520691, "response": "```python\ndef remove_duplicates(paths):\n    seen = set()\n    result = []\n    for path in paths:\n        lower = path.lower()\n        if lower not in seen:\n            seen.add(lower)\n            result.append(path)\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_dedupe_paths_ci", "prompt": "Given a list of file paths, remove duplicates case-insensitively (Windows-style), preserving the first occurrence order. Return only the Python function code, no explanations or test cases.", "entry_point": "dedupe_paths_ci", "canonical_solution": "def dedupe_paths_ci(paths):\n    seen=set(); out=[]\n    for p in paths:\n        k=p.lower()\n        if k not in seen:\n            seen.add(k); out.append(p)\n    return out", "test": [{"input": "['Readme.md','README.md','src/app.py','Src/App.py']", "output": "['Readme.md','src/app.py']"}, {"input": "[]", "output": "[]"}]}}
{"timestamp_utc": "2025-09-29T08:18:39.659443", "dataset_file": "testbench.jsonl", "dataset_index": 29, "question": "Detect a common license name in a text blob. Return 'MIT', 'Apache-2.0', 'GPL', or 'Unknown'. Heuristics: contains 'mit license' -> MIT; 'apache license' and '2.0' -> Apache-2.0; 'gnu general public license' -> GPL. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 11.537963151931763, "response": "```python\ndef detect_license(text):\n    text_lower = text.lower()\n    if 'mit license' in text_lower:\n        return 'MIT'\n    if 'apache license' in text_lower and '2.0' in text_lower:\n        return 'Apache-2.0'\n    if 'gnu general public license' in text_lower:\n        return 'GPL'\n    return 'Unknown'\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_license_detect_simple", "prompt": "Detect a common license name in a text blob. Return 'MIT', 'Apache-2.0', 'GPL', or 'Unknown'. Heuristics: contains 'mit license' -> MIT; 'apache license' and '2.0' -> Apache-2.0; 'gnu general public license' -> GPL. Return only the Python function code, no explanations or test cases.", "entry_point": "detect_license", "canonical_solution": "def detect_license(text):\n    t=text.lower()\n    if 'mit license' in t:\n        return 'MIT'\n    if 'apache license' in t and '2.0' in t:\n        return 'Apache-2.0'\n    if 'gnu general public license' in t:\n        return 'GPL'\n    return 'Unknown'", "test": [{"input": "\"Permission is hereby granted... MIT License\"", "output": "\"MIT\""}, {"input": "\"Apache License Version 2.0\"", "output": "\"Apache-2.0\""}, {"input": "\"Some random text\"", "output": "\"Unknown\""}]}}
{"timestamp_utc": "2025-09-29T08:19:37.006583", "dataset_file": "testbench.jsonl", "dataset_index": 30, "question": "Given a CHANGELOG string with lines like '## [X.Y.Z] - YYYY-MM-DD', return the latest version by semantic version precedence (ignore prerelease). If none found, return ''. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 56.343644857406616, "response": "```python\nimport re\n\ndef get_latest_version(changelog: str) -> str:\n    versions = []\n    for line in changelog.splitlines():\n        match = re.match(r'^## \\[(.*?)\\] - \\d{4}-\\d{2}-\\d{2}$', line.strip())\n        if match:\n            ver_str = match.group(1)\n            if '-' in ver_str or '+' in ver_str:\n                continue\n            parts = ver_str.split('.')\n            if len(parts) != 3:\n                continue\n            try:\n                ver_tuple = tuple(map(int, parts))\n                versions.append((ver_tuple, ver_str))\n            except ValueError:\n                continue\n    if not versions:\n        return ''\n    return max(versions, key=lambda x: x[0])[1]\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_changelog_latest", "prompt": "Given a CHANGELOG string with lines like '## [X.Y.Z] - YYYY-MM-DD', return the latest version by semantic version precedence (ignore prerelease). If none found, return ''. Return only the Python function code, no explanations or test cases.", "entry_point": "latest_changelog_version", "canonical_solution": "def latest_changelog_version(text):\n    vers=[]\n    for line in text.splitlines():\n        line=line.strip()\n        if line.startswith('## [') and ']' in line:\n            v=line[4: line.find(']')]\n            parts=list(map(int,(v.split('.')+['0','0','0'])[:3]))\n            vers.append((parts, v))\n    if not vers:\n        return ''\n    return max(vers)[1]", "test": [{"input": "\"## [1.0.0] - 2020-01-01\\n## [1.2.0] - 2021-01-01\\n## [1.1.9] - 2020-06-01\"", "output": "\"1.2.0\""}, {"input": "\"No versions here\"", "output": "\"\""}]}}
{"timestamp_utc": "2025-09-29T08:20:43.579407", "dataset_file": "testbench.jsonl", "dataset_index": 31, "question": "Parse a GitHub URL of a repository, issue, or pull request and return a tuple (owner, repo, kind, id_or_None) where kind is 'repo', 'issue', or 'pull'. Accept https URLs with or without trailing slashes. Return only the Python function code, no explanations or test cases.", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 65.56714487075806, "response": "```python\ndef parse_github_url(url):\n    url = url.split('?')[0].rstrip('/')\n    path = url[len('https://github.com/'):]\n    parts = path.split('/')\n    if len(parts) == 2:\n        owner, repo = parts\n        return (owner, repo, 'repo', None)\n    elif len(parts) == 4:\n        owner, repo, type_, id_ = parts\n        kind = 'issue' if type_ == 'issues' else 'pull' if type_ == 'pull' else type_\n        return (owner, repo, kind, id_)\n    else:\n        raise ValueError(\"Invalid URL format\")\n```", "error": null, "raw_item": {"task_id": "CustomEval/gh_parse_github_slug", "prompt": "Parse a GitHub URL of a repository, issue, or pull request and return a tuple (owner, repo, kind, id_or_None) where kind is 'repo', 'issue', or 'pull'. Accept https URLs with or without trailing slashes. Return only the Python function code, no explanations or test cases.", "entry_point": "parse_github_url", "canonical_solution": "import re\n\ndef parse_github_url(url):\n    m=re.match(r'^https?://github\\.com/([^/]+)/([^/]+)(?:/(issues|pull)/?(\\d+)?)?/?$', url)\n    if not m:\n        return ('','','',None)\n    owner, repo, kind, num = m.group(1), m.group(2), m.group(3) or 'repo', m.group(4)\n    return (owner, repo, kind, int(num) if num else None)", "test": [{"input": "\"https://github.com/pallets/flask\"", "output": "('pallets','flask','repo',None)"}, {"input": "\"https://github.com/python/cpython/issues/12345\"", "output": "('python','cpython','issues',12345)"}, {"input": "\"https://github.com/psf/requests/pull/1/\"", "output": "('psf','requests','pull',1)"}]}}
{"timestamp_utc": "2025-09-29T08:21:09.581997", "dataset_file": "testbench.jsonl", "dataset_index": 32, "question": "def is_valid_ipv4(ip: str) -> bool:\n    \"\"\"\n    Check if a string is a valid IPv4 address.\n    Valid format: four integers 0-255 separated by dots, no leading zeros.\n    \n    Examples:\n    is_valid_ipv4('192.168.1.1') => True\n    is_valid_ipv4('256.1.1.1') => False  \n    is_valid_ipv4('01.1.1.1') => False\n    is_valid_ipv4('1.1.1') => False\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 24.999617099761963, "response": "```python\ndef is_valid_ipv4(ip: str) -> bool:\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return False\n    for part in parts:\n        if not part.isdigit():\n            return False\n        if len(part) > 1 and part[0] == '0':\n            return False\n        num = int(part)\n        if num < 0 or num > 255:\n            return False\n    return True\n```", "error": null, "raw_item": {"task_id": "CustomEval/164", "prompt": "def is_valid_ipv4(ip: str) -> bool:\n    \"\"\"\n    Check if a string is a valid IPv4 address.\n    Valid format: four integers 0-255 separated by dots, no leading zeros.\n    \n    Examples:\n    is_valid_ipv4('192.168.1.1') => True\n    is_valid_ipv4('256.1.1.1') => False  \n    is_valid_ipv4('01.1.1.1') => False\n    is_valid_ipv4('1.1.1') => False\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "is_valid_ipv4", "canonical_solution": "def is_valid_ipv4(ip: str) -> bool:\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return False\n    \n    for part in parts:\n        if not part or (part[0] == '0' and len(part) > 1):\n            return False\n        if not part.isdigit():\n            return False\n        if int(part) > 255:\n            return False\n    \n    return True", "test": "def check(candidate):\n    assert candidate('192.168.1.1') == True\n    assert candidate('0.0.0.0') == True\n    assert candidate('255.255.255.255') == True\n    assert candidate('256.1.1.1') == False\n    assert candidate('01.1.1.1') == False\n    assert candidate('1.1.1') == False\n    assert candidate('1.1.1.1.1') == False\n    assert candidate('a.1.1.1') == False\n    assert candidate('1..1.1') == False\n    assert candidate('') == False"}}
{"timestamp_utc": "2025-09-29T08:21:22.774985", "dataset_file": "testbench.jsonl", "dataset_index": 33, "question": "def longest_common_subsequence(text1: str, text2: str) -> int:\n    \"\"\"\n    Find the length of the longest common subsequence between two strings.\n    A subsequence is derived by deleting some or no elements without changing\n    the order of remaining elements.\n    \n    Examples:\n    longest_common_subsequence('abcde', 'ace') => 3\n    longest_common_subsequence('abc', 'abc') => 3\n    longest_common_subsequence('abc', 'def') => 0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 12.19163179397583, "response": "```python\ndef longest_common_subsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n```", "error": null, "raw_item": {"task_id": "CustomEval/166", "prompt": "def longest_common_subsequence(text1: str, text2: str) -> int:\n    \"\"\"\n    Find the length of the longest common subsequence between two strings.\n    A subsequence is derived by deleting some or no elements without changing\n    the order of remaining elements.\n    \n    Examples:\n    longest_common_subsequence('abcde', 'ace') => 3\n    longest_common_subsequence('abc', 'abc') => 3\n    longest_common_subsequence('abc', 'def') => 0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "longest_common_subsequence", "canonical_solution": "def longest_common_subsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]", "test": "def check(candidate):\n    assert candidate('abcde', 'ace') == 3\n    assert candidate('abc', 'abc') == 3\n    assert candidate('abc', 'def') == 0\n    assert candidate('', 'abc') == 0\n    assert candidate('abc', '') == 0\n    assert candidate('bl', 'yby') == 1\n    assert candidate('ABCDGH', 'AEDFHR') == 3"}}
{"timestamp_utc": "2025-09-29T08:22:03.222821", "dataset_file": "testbench.jsonl", "dataset_index": 34, "question": "def edit_distance(word1: str, word2: str) -> int:\n    \"\"\"\n    Calculate the minimum edit distance (Levenshtein distance) between two words.\n    Operations allowed: insert, delete, replace a character.\n    \n    Examples:\n    edit_distance('horse', 'ros') => 3\n    edit_distance('intention', 'execution') => 5\n    edit_distance('', 'abc') => 3\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 39.44658398628235, "response": "```python\ndef edit_distance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n    return dp[m][n]\n```", "error": null, "raw_item": {"task_id": "CustomEval/167", "prompt": "def edit_distance(word1: str, word2: str) -> int:\n    \"\"\"\n    Calculate the minimum edit distance (Levenshtein distance) between two words.\n    Operations allowed: insert, delete, replace a character.\n    \n    Examples:\n    edit_distance('horse', 'ros') => 3\n    edit_distance('intention', 'execution') => 5\n    edit_distance('', 'abc') => 3\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "edit_distance", "canonical_solution": "def edit_distance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize base cases\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i-1][j],    # delete\n                    dp[i][j-1],    # insert\n                    dp[i-1][j-1]   # replace\n                )\n    \n    return dp[m][n]", "test": "def check(candidate):\n    assert candidate('horse', 'ros') == 3\n    assert candidate('intention', 'execution') == 5\n    assert candidate('', 'abc') == 3\n    assert candidate('abc', '') == 3\n    assert candidate('same', 'same') == 0\n    assert candidate('a', 'b') == 1\n    assert candidate('abc', 'yabd') == 2"}}
{"timestamp_utc": "2025-09-29T08:22:21.656355", "dataset_file": "testbench.jsonl", "dataset_index": 35, "question": "def count_islands(grid: list) -> int:\n    \"\"\"\n    Count the number of islands in a 2D binary grid.\n    An island is surrounded by water and formed by connecting adjacent\n    lands horizontally or vertically (not diagonally).\n    \n    Examples:\n    count_islands([['1','1','0','0','0'],\n                   ['1','1','0','0','0'],\n                   ['0','0','1','0','0'],\n                   ['0','0','0','1','1']]) => 3\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 17.432005882263184, "response": "```python\ndef count_islands(grid: list) -> int:\n    if not grid or not grid[0]:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0':\n            return\n        grid[r][c] = '0'\n        dfs(r - 1, c)\n        dfs(r + 1, c)\n        dfs(r, c - 1)\n        dfs(r, c + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n    \n    return count\n```", "error": null, "raw_item": {"task_id": "CustomEval/168", "prompt": "def count_islands(grid: list) -> int:\n    \"\"\"\n    Count the number of islands in a 2D binary grid.\n    An island is surrounded by water and formed by connecting adjacent\n    lands horizontally or vertically (not diagonally).\n    \n    Examples:\n    count_islands([['1','1','0','0','0'],\n                   ['1','1','0','0','0'],\n                   ['0','0','1','0','0'],\n                   ['0','0','0','1','1']]) => 3\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "count_islands", "canonical_solution": "def count_islands(grid: list) -> int:\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    islands = 0\n    \n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == '0':\n            return\n        \n        grid[i][j] = '0'  # mark as visited\n        \n        # Check all 4 directions\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                islands += 1\n                dfs(i, j)\n    \n    return islands", "test": "def check(candidate):\n    grid1 = [['1','1','1','1','0'],\n             ['1','1','0','1','0'],\n             ['1','1','0','0','0'],\n             ['0','0','0','0','0']]\n    assert candidate(grid1) == 1\n    \n    grid2 = [['1','1','0','0','0'],\n             ['1','1','0','0','0'],\n             ['0','0','1','0','0'],\n             ['0','0','0','1','1']]\n    assert candidate(grid2) == 3\n    \n    assert candidate([]) == 0\n    assert candidate([['0','0'],['0','0']]) == 0\n    assert candidate([['1']]) == 1"}}
{"timestamp_utc": "2025-09-29T08:22:42.140163", "dataset_file": "testbench.jsonl", "dataset_index": 36, "question": "def binary_search_insert(nums: list, target: int) -> int:\n    \"\"\"\n    Find the index where target should be inserted in sorted array to maintain order.\n    If target exists, return the index of first occurrence.\n    \n    Examples:\n    binary_search_insert([1,3,5,6], 5) => 2\n    binary_search_insert([1,3,5,6], 2) => 1\n    binary_search_insert([1,3,5,6], 7) => 4\n    binary_search_insert([1,3,5,6], 0) => 0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 19.480141162872314, "response": "```python\ndef binary_search_insert(nums: list, target: int) -> int:\n    low = 0\n    high = len(nums)\n    while low < high:\n        mid = (low + high) // 2\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n```", "error": null, "raw_item": {"task_id": "CustomEval/170", "prompt": "def binary_search_insert(nums: list, target: int) -> int:\n    \"\"\"\n    Find the index where target should be inserted in sorted array to maintain order.\n    If target exists, return the index of first occurrence.\n    \n    Examples:\n    binary_search_insert([1,3,5,6], 5) => 2\n    binary_search_insert([1,3,5,6], 2) => 1\n    binary_search_insert([1,3,5,6], 7) => 4\n    binary_search_insert([1,3,5,6], 0) => 0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "binary_search_insert", "canonical_solution": "def binary_search_insert(nums: list, target: int) -> int:\n    left, right = 0, len(nums)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left", "test": "def check(candidate):\n    assert candidate([1,3,5,6], 5) == 2\n    assert candidate([1,3,5,6], 2) == 1\n    assert candidate([1,3,5,6], 7) == 4\n    assert candidate([1,3,5,6], 0) == 0\n    assert candidate([], 1) == 0\n    assert candidate([1], 0) == 0\n    assert candidate([1], 2) == 1\n    assert candidate([1,1,1], 1) == 0"}}
{"timestamp_utc": "2025-09-29T08:23:20.953066", "dataset_file": "testbench.jsonl", "dataset_index": 37, "question": "def merge_k_sorted_lists(lists: list) -> list:\n    \"\"\"\n    Merge k sorted lists into one sorted list.\n    Each list is sorted in ascending order.\n    \n    Examples:\n    merge_k_sorted_lists([[1,4,5],[1,3,4],[2,6]]) => [1,1,2,3,4,4,5,6]\n    merge_k_sorted_lists([]) => []\n    merge_k_sorted_lists([[]]) => []\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 37.8101601600647, "response": "```python\nimport heapq\n\ndef merge_k_sorted_lists(lists: list) -> list:\n    min_heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(min_heap, (lst[0], i, 0))\n    result = []\n    while min_heap:\n        val, list_idx, elem_idx = heapq.heappop(min_heap)\n        result.append(val)\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_val = lists[list_idx][elem_idx + 1]\n            heapq.heappush(min_heap, (next_val, list_idx, elem_idx + 1))\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/171", "prompt": "def merge_k_sorted_lists(lists: list) -> list:\n    \"\"\"\n    Merge k sorted lists into one sorted list.\n    Each list is sorted in ascending order.\n    \n    Examples:\n    merge_k_sorted_lists([[1,4,5],[1,3,4],[2,6]]) => [1,1,2,3,4,4,5,6]\n    merge_k_sorted_lists([]) => []\n    merge_k_sorted_lists([[]]) => []\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "merge_k_sorted_lists", "canonical_solution": "def merge_k_sorted_lists(lists: list) -> list:\n    import heapq\n    \n    if not lists:\n        return []\n    \n    heap = []\n    \n    # Initialize heap with first element from each list\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))  # (value, list_index, element_index)\n    \n    result = []\n    \n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(val)\n        \n        # Add next element from the same list\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_val = lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n    \n    return result", "test": "def check(candidate):\n    assert candidate([[1,4,5],[1,3,4],[2,6]]) == [1,1,2,3,4,4,5,6]\n    assert candidate([]) == []\n    assert candidate([[]]) == []\n    assert candidate([[1],[2],[3]]) == [1,2,3]\n    assert candidate([[1,2,3]]) == [1,2,3]\n    assert candidate([[-1,0,1],[2,3,4]]) == [-1,0,1,2,3,4]"}}
{"timestamp_utc": "2025-09-29T08:23:53.920402", "dataset_file": "testbench.jsonl", "dataset_index": 38, "question": "def sliding_window_maximum(nums: list, k: int) -> list:\n    \"\"\"\n    Find the maximum in each sliding window of size k.\n    \n    Examples:\n    sliding_window_maximum([1,3,-1,-3,5,3,6,7], 3) => [3,3,5,5,6,7]\n    sliding_window_maximum([1], 1) => [1]\n    sliding_window_maximum([1,-1], 1) => [1,-1]\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 31.963575839996338, "response": "```python\nfrom collections import deque\n\ndef sliding_window_maximum(nums: list, k: int) -> list:\n    if not nums or k == 0:\n        return []\n    n = len(nums)\n    result = []\n    dq = deque()\n    for i in range(n):\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        dq.append(i)\n        if dq[0] == i - k:\n            dq.popleft()\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/172", "prompt": "def sliding_window_maximum(nums: list, k: int) -> list:\n    \"\"\"\n    Find the maximum in each sliding window of size k.\n    \n    Examples:\n    sliding_window_maximum([1,3,-1,-3,5,3,6,7], 3) => [3,3,5,5,6,7]\n    sliding_window_maximum([1], 1) => [1]\n    sliding_window_maximum([1,-1], 1) => [1,-1]\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "sliding_window_maximum", "canonical_solution": "def sliding_window_maximum(nums: list, k: int) -> list:\n    from collections import deque\n    \n    if not nums or k == 0:\n        return []\n    \n    if k == 1:\n        return nums\n    \n    dq = deque()  # stores indices\n    result = []\n    \n    for i in range(len(nums)):\n        # Remove indices outside current window\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove indices of smaller elements\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Add maximum to result if window is complete\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result", "test": "def check(candidate):\n    assert candidate([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7]\n    assert candidate([1], 1) == [1]\n    assert candidate([1,-1], 1) == [1,-1]\n    assert candidate([9,11], 2) == [11]\n    assert candidate([4,-2], 2) == [4]\n    assert candidate([1,2,3,4], 2) == [2,3,4]"}}
{"timestamp_utc": "2025-09-29T08:24:54.437105", "dataset_file": "testbench.jsonl", "dataset_index": 39, "question": "def longest_increasing_subsequence(nums: list) -> int:\n    \"\"\"\n    Find the length of the longest strictly increasing subsequence.\n    \n    Examples:\n    longest_increasing_subsequence([10,9,2,5,3,7,101,18]) => 4\n    longest_increasing_subsequence([0,1,0,3,2,3]) => 4\n    longest_increasing_subsequence([7,7,7,7,7,7,7]) => 1\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 59.514729022979736, "response": "```python\ndef longest_increasing_subsequence(nums: list) -> int:\n    tails = []\n    for num in nums:\n        left, right = 0, len(tails)\n        while left < right:\n            mid = (left + right) // 2\n            if tails[mid] < num:\n                left = mid + 1\n            else:\n                right = mid\n        pos = left\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    return len(tails)\n```", "error": null, "raw_item": {"task_id": "CustomEval/173", "prompt": "def longest_increasing_subsequence(nums: list) -> int:\n    \"\"\"\n    Find the length of the longest strictly increasing subsequence.\n    \n    Examples:\n    longest_increasing_subsequence([10,9,2,5,3,7,101,18]) => 4\n    longest_increasing_subsequence([0,1,0,3,2,3]) => 4\n    longest_increasing_subsequence([7,7,7,7,7,7,7]) => 1\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "longest_increasing_subsequence", "canonical_solution": "def longest_increasing_subsequence(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    # Binary search approach - O(n log n)\n    import bisect\n    \n    tails = []\n    \n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    \n    return len(tails)", "test": "def check(candidate):\n    assert candidate([10,9,2,5,3,7,101,18]) == 4\n    assert candidate([0,1,0,3,2,3]) == 4\n    assert candidate([7,7,7,7,7,7,7]) == 1\n    assert candidate([]) == 0\n    assert candidate([1,3,6,7,9,4,10,5,6]) == 6\n    assert candidate([10,22,9,33,21,50,41,60]) == 5"}}
{"timestamp_utc": "2025-09-29T08:25:47.989965", "dataset_file": "testbench.jsonl", "dataset_index": 40, "question": "def find_median_sorted_arrays(nums1: list, nums2: list) -> float:\n    \"\"\"\n    Find the median of two sorted arrays in O(log(min(m,n))) time.\n    \n    Examples:\n    find_median_sorted_arrays([1,3], [2]) => 2.0\n    find_median_sorted_arrays([1,2], [3,4]) => 2.5\n    find_median_sorted_arrays([0,0], [0,0]) => 0.0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 52.550190925598145, "response": "```python\ndef find_median_sorted_arrays(nums1: list, nums2: list) -> float:\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    left_size = (m + n + 1) // 2\n    low, high = 0, m\n    while low <= high:\n        i = (low + high) // 2\n        j = left_size - i\n        nums1_left_max = float('-inf') if i == 0 else nums1[i - 1]\n        nums1_right_min = float('inf') if i == m else nums1[i]\n        nums2_left_max = float('-inf') if j == 0 else nums2[j - 1]\n        nums2_right_min = float('inf') if j == n else nums2[j]\n        if nums1_left_max <= nums2_right_min and nums2_left_max <= nums1_right_min:\n            if (m + n) % 2 == 1:\n                return max(nums1_left_max, nums2_left_max)\n            else:\n                return (max(nums1_left_max, nums2_left_max) + min(nums1_right_min, nums2_right_min)) / 2\n        elif nums1_left_max > nums2_right_min:\n            high = i - 1\n        else:\n            low = i + 1\n```", "error": null, "raw_item": {"task_id": "CustomEval/174", "prompt": "def find_median_sorted_arrays(nums1: list, nums2: list) -> float:\n    \"\"\"\n    Find the median of two sorted arrays in O(log(min(m,n))) time.\n    \n    Examples:\n    find_median_sorted_arrays([1,3], [2]) => 2.0\n    find_median_sorted_arrays([1,2], [3,4]) => 2.5\n    find_median_sorted_arrays([0,0], [0,0]) => 0.0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "find_median_sorted_arrays", "canonical_solution": "def find_median_sorted_arrays(nums1: list, nums2: list) -> float:\n    # Ensure nums1 is the smaller array\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    \n    left, right = 0, m\n    \n    while left <= right:\n        partition1 = (left + right) // 2\n        partition2 = (m + n + 1) // 2 - partition1\n        \n        maxLeft1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]\n        maxLeft2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]\n        \n        minRight1 = float('inf') if partition1 == m else nums1[partition1]\n        minRight2 = float('inf') if partition2 == n else nums2[partition2]\n        \n        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n            if (m + n) % 2 == 0:\n                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0\n            else:\n                return max(maxLeft1, maxLeft2)\n        \n        elif maxLeft1 > minRight2:\n            right = partition1 - 1\n        else:\n            left = partition1 + 1", "test": "def check(candidate):\n    assert candidate([1,3], [2]) == 2.0\n    assert candidate([1,2], [3,4]) == 2.5\n    assert candidate([0,0], [0,0]) == 0.0\n    assert candidate([], [1]) == 1.0\n    assert candidate([2], []) == 2.0\n    assert candidate([1,3], [2,4]) == 2.5\n    assert candidate([1,2,3], [4,5,6]) == 3.5"}}
{"timestamp_utc": "2025-09-29T08:26:27.618239", "dataset_file": "testbench.jsonl", "dataset_index": 41, "question": "def regular_expression_match(s: str, p: str) -> bool:\n    \"\"\"\n    Implement regular expression matching with '.' and '*'.\n    '.' matches any single character\n    '*' matches zero or more of the preceding element\n    \n    Examples:\n    regular_expression_match('aa', 'a') => False\n    regular_expression_match('aa', 'a*') => True\n    regular_expression_match('ab', '.*') => True\n    regular_expression_match('aab', 'c*a*b') => True\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 38.62402415275574, "response": "```python\ndef regular_expression_match(s: str, p: str) -> bool:\n    \"\"\"\n    Implement regular expression matching with '.' and '*'.\n    '.' matches any single character\n    '*' matches zero or more of the preceding element\n    \n    Examples:\n    regular_expression_match('aa', 'a') => False\n    regular_expression_match('aa', 'a*') => True\n    regular_expression_match('ab', '.*') => True\n    regular_expression_match('aab', 'c*a*b') => True\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    \n    def matches(x: str, y: str) -> bool:\n        return x == y or y == '.'\n    \n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and j >= 2:\n            dp[0][j] = dp[0][j - 2]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] != '*':\n                if matches(s[i - 1], p[j - 1]):\n                    dp[i][j] = dp[i - 1][j - 1]\n            else:\n                if j >= 2:\n                    dp[i][j] = dp[i][j - 2]\n                    if matches(s[i - 1], p[j - 2]):\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n    \n    return dp[m][n]\n```", "error": null, "raw_item": {"task_id": "CustomEval/175", "prompt": "def regular_expression_match(s: str, p: str) -> bool:\n    \"\"\"\n    Implement regular expression matching with '.' and '*'.\n    '.' matches any single character\n    '*' matches zero or more of the preceding element\n    \n    Examples:\n    regular_expression_match('aa', 'a') => False\n    regular_expression_match('aa', 'a*') => True\n    regular_expression_match('ab', '.*') => True\n    regular_expression_match('aab', 'c*a*b') => True\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "regular_expression_match", "canonical_solution": "def regular_expression_match(s: str, p: str) -> bool:\n    dp = {}\n    \n    def dfs(i, j):\n        if (i, j) in dp:\n            return dp[(i, j)]\n        \n        if j == len(p):\n            return i == len(s)\n        \n        first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')\n        \n        if j + 1 < len(p) and p[j + 1] == '*':\n            result = (dfs(i, j + 2) or  # match 0 occurrences\n                     (first_match and dfs(i + 1, j)))  # match 1+ occurrences\n        else:\n            result = first_match and dfs(i + 1, j + 1)\n        \n        dp[(i, j)] = result\n        return result\n    \n    return dfs(0, 0)", "test": "def check(candidate):\n    assert candidate('aa', 'a') == False\n    assert candidate('aa', 'a*') == True\n    assert candidate('ab', '.*') == True\n    assert candidate('aab', 'c*a*b') == True\n    assert candidate('mississippi', 'mis*is*p*.') == False\n    assert candidate('', '') == True\n    assert candidate('', 'a*') == True\n    assert candidate('a', 'ab*') == True"}}
{"timestamp_utc": "2025-09-29T08:27:01.821343", "dataset_file": "testbench.jsonl", "dataset_index": 42, "question": "def is_valid_ipv4(ip: str) -> bool:\n    \"\"\"\n    Check if a string is a valid IPv4 address.\n    Valid format: four integers 0-255 separated by dots, no leading zeros.\n    \n    Examples:\n    is_valid_ipv4('192.168.1.1') => True\n    is_valid_ipv4('256.1.1.1') => False  \n    is_valid_ipv4('01.1.1.1') => False\n    is_valid_ipv4('1.1.1') => False\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 33.20174479484558, "response": "```python\ndef is_valid_ipv4(ip: str) -> bool:\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return False\n    for part in parts:\n        if not part.isdigit():\n            return False\n        num = int(part)\n        if num < 0 or num > 255:\n            return False\n        if len(part) > 1 and part[0] == '0':\n            return False\n    return True\n```", "error": null, "raw_item": {"task_id": "CustomEval/164", "prompt": "def is_valid_ipv4(ip: str) -> bool:\n    \"\"\"\n    Check if a string is a valid IPv4 address.\n    Valid format: four integers 0-255 separated by dots, no leading zeros.\n    \n    Examples:\n    is_valid_ipv4('192.168.1.1') => True\n    is_valid_ipv4('256.1.1.1') => False  \n    is_valid_ipv4('01.1.1.1') => False\n    is_valid_ipv4('1.1.1') => False\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "is_valid_ipv4", "canonical_solution": "def is_valid_ipv4(ip: str) -> bool:\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return False\n    \n    for part in parts:\n        if not part or (part[0] == '0' and len(part) > 1):\n            return False\n        if not part.isdigit():\n            return False\n        if int(part) > 255:\n            return False\n    \n    return True", "test": "def check(candidate):\n    assert candidate('192.168.1.1') == True\n    assert candidate('0.0.0.0') == True\n    assert candidate('255.255.255.255') == True\n    assert candidate('256.1.1.1') == False\n    assert candidate('01.1.1.1') == False\n    assert candidate('1.1.1') == False\n    assert candidate('1.1.1.1.1') == False\n    assert candidate('a.1.1.1') == False\n    assert candidate('1..1.1') == False\n    assert candidate('') == False"}}
{"timestamp_utc": "2025-09-29T08:27:34.279784", "dataset_file": "testbench.jsonl", "dataset_index": 43, "question": "def knapsack_01(weights: list, values: list, capacity: int) -> int:\n    \"\"\"\n    Solve the 0/1 knapsack problem using dynamic programming.\n    Return the maximum value that can be obtained.\n    \n    Args:\n    - weights: list of item weights\n    - values: list of item values  \n    - capacity: knapsack capacity\n    \n    Examples:\n    knapsack_01([1, 2, 3], [60, 100, 120], 5) => 220\n    knapsack_01([10, 20, 30], [60, 100, 120], 50) => 220\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 31.45551586151123, "response": "```python\ndef knapsack_01(weights: list, values: list, capacity: int) -> int:\n    \"\"\"\n    Solve the 0/1 knapsack problem using dynamic programming.\n    Return the maximum value that can be obtained.\n    \n    Args:\n    - weights: list of item weights\n    - values: list of item values  \n    - capacity: knapsack capacity\n    \n    Examples:\n    knapsack_01([1, 2, 3], [60, 100, 120], 5) => 220\n    knapsack_01([10, 20, 30], [60, 100, 120], 50) => 220\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n    n = len(weights)\n    dp = [0] * (capacity + 1)\n    for i in range(n):\n        for w in range(capacity, weights[i] - 1, -1):\n            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])\n    return dp[capacity]\n```", "error": null, "raw_item": {"task_id": "CustomEval/165", "prompt": "def knapsack_01(weights: list, values: list, capacity: int) -> int:\n    \"\"\"\n    Solve the 0/1 knapsack problem using dynamic programming.\n    Return the maximum value that can be obtained.\n    \n    Args:\n    - weights: list of item weights\n    - values: list of item values  \n    - capacity: knapsack capacity\n    \n    Examples:\n    knapsack_01([1, 2, 3], [60, 100, 120], 5) => 220\n    knapsack_01([10, 20, 30], [60, 100, 120], 50) => 220\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "knapsack_01", "canonical_solution": "def knapsack_01(weights: list, values: list, capacity: int) -> int:\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(\n                    dp[i-1][w],  # don't take item\n                    dp[i-1][w - weights[i-1]] + values[i-1]  # take item\n                )\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    return dp[n][capacity]", "test": "def check(candidate):\n    assert candidate([1, 2, 3], [60, 100, 120], 5) == 220\n    assert candidate([10, 20, 30], [60, 100, 120], 50) == 220\n    assert candidate([2, 3, 4, 5], [3, 4, 5, 6], 5) == 7\n    assert candidate([1], [10], 1) == 10\n    assert candidate([1], [10], 0) == 0\n    assert candidate([], [], 10) == 0"}}
{"timestamp_utc": "2025-09-29T08:27:48.535297", "dataset_file": "testbench.jsonl", "dataset_index": 44, "question": "def longest_common_subsequence(text1: str, text2: str) -> int:\n    \"\"\"\n    Find the length of the longest common subsequence between two strings.\n    A subsequence is derived by deleting some or no elements without changing\n    the order of remaining elements.\n    \n    Examples:\n    longest_common_subsequence('abcde', 'ace') => 3\n    longest_common_subsequence('abc', 'abc') => 3\n    longest_common_subsequence('abc', 'def') => 0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 13.253246784210205, "response": "```python\ndef longest_common_subsequence(text1: str, text2: str) -> int:\n    \"\"\"\n    Find the length of the longest common subsequence between two strings.\n    A subsequence is derived by deleting some or no elements without changing\n    the order of remaining elements.\n    \n    Examples:\n    longest_common_subsequence('abcde', 'ace') => 3\n    longest_common_subsequence('abc', 'abc') => 3\n    longest_common_subsequence('abc', 'def') => 0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n```", "error": null, "raw_item": {"task_id": "CustomEval/166", "prompt": "def longest_common_subsequence(text1: str, text2: str) -> int:\n    \"\"\"\n    Find the length of the longest common subsequence between two strings.\n    A subsequence is derived by deleting some or no elements without changing\n    the order of remaining elements.\n    \n    Examples:\n    longest_common_subsequence('abcde', 'ace') => 3\n    longest_common_subsequence('abc', 'abc') => 3\n    longest_common_subsequence('abc', 'def') => 0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "longest_common_subsequence", "canonical_solution": "def longest_common_subsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]", "test": "def check(candidate):\n    assert candidate('abcde', 'ace') == 3\n    assert candidate('abc', 'abc') == 3\n    assert candidate('abc', 'def') == 0\n    assert candidate('', 'abc') == 0\n    assert candidate('abc', '') == 0\n    assert candidate('bl', 'yby') == 1\n    assert candidate('ABCDGH', 'AEDFHR') == 3"}}
{"timestamp_utc": "2025-09-29T08:28:05.925990", "dataset_file": "testbench.jsonl", "dataset_index": 45, "question": "def edit_distance(word1: str, word2: str) -> int:\n    \"\"\"\n    Calculate the minimum edit distance (Levenshtein distance) between two words.\n    Operations allowed: insert, delete, replace a character.\n    \n    Examples:\n    edit_distance('horse', 'ros') => 3\n    edit_distance('intention', 'execution') => 5\n    edit_distance('', 'abc') => 3\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 16.38878083229065, "response": "```python\ndef edit_distance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n    return dp[m][n]\n```", "error": null, "raw_item": {"task_id": "CustomEval/167", "prompt": "def edit_distance(word1: str, word2: str) -> int:\n    \"\"\"\n    Calculate the minimum edit distance (Levenshtein distance) between two words.\n    Operations allowed: insert, delete, replace a character.\n    \n    Examples:\n    edit_distance('horse', 'ros') => 3\n    edit_distance('intention', 'execution') => 5\n    edit_distance('', 'abc') => 3\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "edit_distance", "canonical_solution": "def edit_distance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize base cases\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i-1][j],    # delete\n                    dp[i][j-1],    # insert\n                    dp[i-1][j-1]   # replace\n                )\n    \n    return dp[m][n]", "test": "def check(candidate):\n    assert candidate('horse', 'ros') == 3\n    assert candidate('intention', 'execution') == 5\n    assert candidate('', 'abc') == 3\n    assert candidate('abc', '') == 3\n    assert candidate('same', 'same') == 0\n    assert candidate('a', 'b') == 1\n    assert candidate('abc', 'yabd') == 2"}}
{"timestamp_utc": "2025-09-29T08:28:23.534884", "dataset_file": "testbench.jsonl", "dataset_index": 46, "question": "def count_islands(grid: list) -> int:\n    \"\"\"\n    Count the number of islands in a 2D binary grid.\n    An island is surrounded by water and formed by connecting adjacent\n    lands horizontally or vertically (not diagonally).\n    \n    Examples:\n    count_islands([['1','1','0','0','0'],\n                   ['1','1','0','0','0'],\n                   ['0','0','1','0','0'],\n                   ['0','0','0','1','1']]) => 3\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 16.60464096069336, "response": "```python\ndef count_islands(grid: list) -> int:\n    \"\"\"\n    Count the number of islands in a 2D binary grid.\n    An island is surrounded by water and formed by connecting adjacent\n    lands horizontally or vertically (not diagonally).\n    \n    Examples:\n    count_islands([['1','1','0','0','0'],\n                   ['1','1','0','0','0'],\n                   ['0','0','1','0','0'],\n                   ['0','0','0','1','1']]) => 3\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    count = 0\n    \n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == '0':\n            return\n        grid[i][j] = '0'\n        dfs(i - 1, j)\n        dfs(i + 1, j)\n        dfs(i, j - 1)\n        dfs(i, j + 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n    \n    return count\n```", "error": null, "raw_item": {"task_id": "CustomEval/168", "prompt": "def count_islands(grid: list) -> int:\n    \"\"\"\n    Count the number of islands in a 2D binary grid.\n    An island is surrounded by water and formed by connecting adjacent\n    lands horizontally or vertically (not diagonally).\n    \n    Examples:\n    count_islands([['1','1','0','0','0'],\n                   ['1','1','0','0','0'],\n                   ['0','0','1','0','0'],\n                   ['0','0','0','1','1']]) => 3\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "count_islands", "canonical_solution": "def count_islands(grid: list) -> int:\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    islands = 0\n    \n    def dfs(i, j):\n        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] == '0':\n            return\n        \n        grid[i][j] = '0'  # mark as visited\n        \n        # Check all 4 directions\n        dfs(i + 1, j)\n        dfs(i - 1, j)\n        dfs(i, j + 1)\n        dfs(i, j - 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                islands += 1\n                dfs(i, j)\n    \n    return islands", "test": "def check(candidate):\n    grid1 = [['1','1','1','1','0'],\n             ['1','1','0','1','0'],\n             ['1','1','0','0','0'],\n             ['0','0','0','0','0']]\n    assert candidate(grid1) == 1\n    \n    grid2 = [['1','1','0','0','0'],\n             ['1','1','0','0','0'],\n             ['0','0','1','0','0'],\n             ['0','0','0','1','1']]\n    assert candidate(grid2) == 3\n    \n    assert candidate([]) == 0\n    assert candidate([['0','0'],['0','0']]) == 0\n    assert candidate([['1']]) == 1"}}
{"timestamp_utc": "2025-09-29T08:28:43.723233", "dataset_file": "testbench.jsonl", "dataset_index": 47, "question": "def valid_parentheses_stack(s: str) -> bool:\n    \"\"\"\n    Check if string of parentheses is valid using stack approach.\n    Valid means: (), [], {} are properly nested and matched.\n    \n    Examples:\n    valid_parentheses_stack('()[]{}') => True\n    valid_parentheses_stack('([)]') => False\n    valid_parentheses_stack('{[()]}') => True\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 19.18664789199829, "response": "```python\ndef valid_parentheses_stack(s: str) -> bool:\n    \"\"\"\n    Check if string of parentheses is valid using stack approach.\n    Valid means: (), [], {} are properly nested and matched.\n    \n    Examples:\n    valid_parentheses_stack('()[]{}') => True\n    valid_parentheses_stack('([)]') => False\n    valid_parentheses_stack('{[()]}') => True\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    return not stack\n```", "error": null, "raw_item": {"task_id": "CustomEval/169", "prompt": "def valid_parentheses_stack(s: str) -> bool:\n    \"\"\"\n    Check if string of parentheses is valid using stack approach.\n    Valid means: (), [], {} are properly nested and matched.\n    \n    Examples:\n    valid_parentheses_stack('()[]{}') => True\n    valid_parentheses_stack('([)]') => False\n    valid_parentheses_stack('{[()]}') => True\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "valid_parentheses_stack", "canonical_solution": "def valid_parentheses_stack(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    \n    return len(stack) == 0", "test": "def check(candidate):\n    assert candidate('()[]{}') == True\n    assert candidate('([)]') == False\n    assert candidate('{[()]}') == True\n    assert candidate('') == True\n    assert candidate('(') == False\n    assert candidate(')') == False\n    assert candidate('((()))') == True\n    assert candidate('({[]})') == True"}}
{"timestamp_utc": "2025-09-29T08:29:01.216153", "dataset_file": "testbench.jsonl", "dataset_index": 48, "question": "def binary_search_insert(nums: list, target: int) -> int:\n    \"\"\"\n    Find the index where target should be inserted in sorted array to maintain order.\n    If target exists, return the index of first occurrence.\n    \n    Examples:\n    binary_search_insert([1,3,5,6], 5) => 2\n    binary_search_insert([1,3,5,6], 2) => 1\n    binary_search_insert([1,3,5,6], 7) => 4\n    binary_search_insert([1,3,5,6], 0) => 0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 16.490664958953857, "response": "```python\ndef binary_search_insert(nums: list, target: int) -> int:\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if nums[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n```", "error": null, "raw_item": {"task_id": "CustomEval/170", "prompt": "def binary_search_insert(nums: list, target: int) -> int:\n    \"\"\"\n    Find the index where target should be inserted in sorted array to maintain order.\n    If target exists, return the index of first occurrence.\n    \n    Examples:\n    binary_search_insert([1,3,5,6], 5) => 2\n    binary_search_insert([1,3,5,6], 2) => 1\n    binary_search_insert([1,3,5,6], 7) => 4\n    binary_search_insert([1,3,5,6], 0) => 0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "binary_search_insert", "canonical_solution": "def binary_search_insert(nums: list, target: int) -> int:\n    left, right = 0, len(nums)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left", "test": "def check(candidate):\n    assert candidate([1,3,5,6], 5) == 2\n    assert candidate([1,3,5,6], 2) == 1\n    assert candidate([1,3,5,6], 7) == 4\n    assert candidate([1,3,5,6], 0) == 0\n    assert candidate([], 1) == 0\n    assert candidate([1], 0) == 0\n    assert candidate([1], 2) == 1\n    assert candidate([1,1,1], 1) == 0"}}
{"timestamp_utc": "2025-09-29T08:29:27.328728", "dataset_file": "testbench.jsonl", "dataset_index": 49, "question": "def merge_k_sorted_lists(lists: list) -> list:\n    \"\"\"\n    Merge k sorted lists into one sorted list.\n    Each list is sorted in ascending order.\n    \n    Examples:\n    merge_k_sorted_lists([[1,4,5],[1,3,4],[2,6]]) => [1,1,2,3,4,4,5,6]\n    merge_k_sorted_lists([]) => []\n    merge_k_sorted_lists([[]]) => []\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 25.110846996307373, "response": "```python\nimport heapq\n\ndef merge_k_sorted_lists(lists: list) -> list:\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    result = []\n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(val)\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_val = lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/171", "prompt": "def merge_k_sorted_lists(lists: list) -> list:\n    \"\"\"\n    Merge k sorted lists into one sorted list.\n    Each list is sorted in ascending order.\n    \n    Examples:\n    merge_k_sorted_lists([[1,4,5],[1,3,4],[2,6]]) => [1,1,2,3,4,4,5,6]\n    merge_k_sorted_lists([]) => []\n    merge_k_sorted_lists([[]]) => []\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "merge_k_sorted_lists", "canonical_solution": "def merge_k_sorted_lists(lists: list) -> list:\n    import heapq\n    \n    if not lists:\n        return []\n    \n    heap = []\n    \n    # Initialize heap with first element from each list\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))  # (value, list_index, element_index)\n    \n    result = []\n    \n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        result.append(val)\n        \n        # Add next element from the same list\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_val = lists[list_idx][elem_idx + 1]\n            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n    \n    return result", "test": "def check(candidate):\n    assert candidate([[1,4,5],[1,3,4],[2,6]]) == [1,1,2,3,4,4,5,6]\n    assert candidate([]) == []\n    assert candidate([[]]) == []\n    assert candidate([[1],[2],[3]]) == [1,2,3]\n    assert candidate([[1,2,3]]) == [1,2,3]\n    assert candidate([[-1,0,1],[2,3,4]]) == [-1,0,1,2,3,4]"}}
{"timestamp_utc": "2025-09-29T08:30:04.593658", "dataset_file": "testbench.jsonl", "dataset_index": 50, "question": "def sliding_window_maximum(nums: list, k: int) -> list:\n    \"\"\"\n    Find the maximum in each sliding window of size k.\n    \n    Examples:\n    sliding_window_maximum([1,3,-1,-3,5,3,6,7], 3) => [3,3,5,5,6,7]\n    sliding_window_maximum([1], 1) => [1]\n    sliding_window_maximum([1,-1], 1) => [1,-1]\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 36.26280426979065, "response": "```python\nfrom collections import deque\n\ndef sliding_window_maximum(nums: list, k: int) -> list:\n    if not nums or k == 0:\n        return []\n    n = len(nums)\n    result = []\n    dq = deque()\n    for i in range(n):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        dq.append(i)\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    return result\n```", "error": null, "raw_item": {"task_id": "CustomEval/172", "prompt": "def sliding_window_maximum(nums: list, k: int) -> list:\n    \"\"\"\n    Find the maximum in each sliding window of size k.\n    \n    Examples:\n    sliding_window_maximum([1,3,-1,-3,5,3,6,7], 3) => [3,3,5,5,6,7]\n    sliding_window_maximum([1], 1) => [1]\n    sliding_window_maximum([1,-1], 1) => [1,-1]\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "sliding_window_maximum", "canonical_solution": "def sliding_window_maximum(nums: list, k: int) -> list:\n    from collections import deque\n    \n    if not nums or k == 0:\n        return []\n    \n    if k == 1:\n        return nums\n    \n    dq = deque()  # stores indices\n    result = []\n    \n    for i in range(len(nums)):\n        # Remove indices outside current window\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove indices of smaller elements\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Add maximum to result if window is complete\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result", "test": "def check(candidate):\n    assert candidate([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7]\n    assert candidate([1], 1) == [1]\n    assert candidate([1,-1], 1) == [1,-1]\n    assert candidate([9,11], 2) == [11]\n    assert candidate([4,-2], 2) == [4]\n    assert candidate([1,2,3,4], 2) == [2,3,4]"}}
{"timestamp_utc": "2025-09-29T08:31:03.379107", "dataset_file": "testbench.jsonl", "dataset_index": 51, "question": "def longest_increasing_subsequence(nums: list) -> int:\n    \"\"\"\n    Find the length of the longest strictly increasing subsequence.\n    \n    Examples:\n    longest_increasing_subsequence([10,9,2,5,3,7,101,18]) => 4\n    longest_increasing_subsequence([0,1,0,3,2,3]) => 4\n    longest_increasing_subsequence([7,7,7,7,7,7,7]) => 1\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 57.78282189369202, "response": "```python\ndef longest_increasing_subsequence(nums: list) -> int:\n    tails = []\n    for num in nums:\n        left, right = 0, len(tails)\n        while left < right:\n            mid = (left + right) // 2\n            if tails[mid] < num:\n                left = mid + 1\n            else:\n                right = mid\n        if left == len(tails):\n            tails.append(num)\n        else:\n            tails[left] = num\n    return len(tails)\n```", "error": null, "raw_item": {"task_id": "CustomEval/173", "prompt": "def longest_increasing_subsequence(nums: list) -> int:\n    \"\"\"\n    Find the length of the longest strictly increasing subsequence.\n    \n    Examples:\n    longest_increasing_subsequence([10,9,2,5,3,7,101,18]) => 4\n    longest_increasing_subsequence([0,1,0,3,2,3]) => 4\n    longest_increasing_subsequence([7,7,7,7,7,7,7]) => 1\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "longest_increasing_subsequence", "canonical_solution": "def longest_increasing_subsequence(nums: list) -> int:\n    if not nums:\n        return 0\n    \n    # Binary search approach - O(n log n)\n    import bisect\n    \n    tails = []\n    \n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    \n    return len(tails)", "test": "def check(candidate):\n    assert candidate([10,9,2,5,3,7,101,18]) == 4\n    assert candidate([0,1,0,3,2,3]) == 4\n    assert candidate([7,7,7,7,7,7,7]) == 1\n    assert candidate([]) == 0\n    assert candidate([1,3,6,7,9,4,10,5,6]) == 6\n    assert candidate([10,22,9,33,21,50,41,60]) == 5"}}
{"timestamp_utc": "2025-09-29T08:31:54.986055", "dataset_file": "testbench.jsonl", "dataset_index": 52, "question": "def find_median_sorted_arrays(nums1: list, nums2: list) -> float:\n    \"\"\"\n    Find the median of two sorted arrays in O(log(min(m,n))) time.\n    \n    Examples:\n    find_median_sorted_arrays([1,3], [2]) => 2.0\n    find_median_sorted_arrays([1,2], [3,4]) => 2.5\n    find_median_sorted_arrays([0,0], [0,0]) => 0.0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 50.604763984680176, "response": "```python\ndef find_median_sorted_arrays(nums1: list, nums2: list) -> float:\n    m, n = len(nums1), len(nums2)\n    if m > n:\n        nums1, nums2 = nums2, nums1\n        m, n = n, m\n    low, high = 0, m\n    total = m + n\n    half = (total + 1) // 2\n    while low <= high:\n        i = (low + high) // 2\n        j = half - i\n        left1 = nums1[i - 1] if i > 0 else float('-inf')\n        right1 = nums1[i] if i < m else float('inf')\n        left2 = nums2[j - 1] if j > 0 else float('-inf')\n        right2 = nums2[j] if j < n else float('inf')\n        if left1 <= right2 and left2 <= right1:\n            if total % 2 == 1:\n                return max(left1, left2)\n            else:\n                return (max(left1, left2) + min(right1, right2)) / 2\n        elif left1 > right2:\n            high = i - 1\n        else:\n            low = i + 1\n    return 0.0  # Should not reach here for valid inputs\n```", "error": null, "raw_item": {"task_id": "CustomEval/174", "prompt": "def find_median_sorted_arrays(nums1: list, nums2: list) -> float:\n    \"\"\"\n    Find the median of two sorted arrays in O(log(min(m,n))) time.\n    \n    Examples:\n    find_median_sorted_arrays([1,3], [2]) => 2.0\n    find_median_sorted_arrays([1,2], [3,4]) => 2.5\n    find_median_sorted_arrays([0,0], [0,0]) => 0.0\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "find_median_sorted_arrays", "canonical_solution": "def find_median_sorted_arrays(nums1: list, nums2: list) -> float:\n    # Ensure nums1 is the smaller array\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    \n    left, right = 0, m\n    \n    while left <= right:\n        partition1 = (left + right) // 2\n        partition2 = (m + n + 1) // 2 - partition1\n        \n        maxLeft1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]\n        maxLeft2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]\n        \n        minRight1 = float('inf') if partition1 == m else nums1[partition1]\n        minRight2 = float('inf') if partition2 == n else nums2[partition2]\n        \n        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n            if (m + n) % 2 == 0:\n                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0\n            else:\n                return max(maxLeft1, maxLeft2)\n        \n        elif maxLeft1 > minRight2:\n            right = partition1 - 1\n        else:\n            left = partition1 + 1", "test": "def check(candidate):\n    assert candidate([1,3], [2]) == 2.0\n    assert candidate([1,2], [3,4]) == 2.5\n    assert candidate([0,0], [0,0]) == 0.0\n    assert candidate([], [1]) == 1.0\n    assert candidate([2], []) == 2.0\n    assert candidate([1,3], [2,4]) == 2.5\n    assert candidate([1,2,3], [4,5,6]) == 3.5"}}
{"timestamp_utc": "2025-09-29T08:32:53.723470", "dataset_file": "testbench.jsonl", "dataset_index": 53, "question": "def regular_expression_match(s: str, p: str) -> bool:\n    \"\"\"\n    Implement regular expression matching with '.' and '*'.\n    '.' matches any single character\n    '*' matches zero or more of the preceding element\n    \n    Examples:\n    regular_expression_match('aa', 'a') => False\n    regular_expression_match('aa', 'a*') => True\n    regular_expression_match('ab', '.*') => True\n    regular_expression_match('aab', 'c*a*b') => True\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 57.734955072402954, "response": "```python\ndef regular_expression_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for j in range(1, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                    dp[i][j] = dp[i][j - 2] or dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i][j - 2]\n            else:\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n    return dp[m][n]\n```", "error": null, "raw_item": {"task_id": "CustomEval/175", "prompt": "def regular_expression_match(s: str, p: str) -> bool:\n    \"\"\"\n    Implement regular expression matching with '.' and '*'.\n    '.' matches any single character\n    '*' matches zero or more of the preceding element\n    \n    Examples:\n    regular_expression_match('aa', 'a') => False\n    regular_expression_match('aa', 'a*') => True\n    regular_expression_match('ab', '.*') => True\n    regular_expression_match('aab', 'c*a*b') => True\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "regular_expression_match", "canonical_solution": "def regular_expression_match(s: str, p: str) -> bool:\n    dp = {}\n    \n    def dfs(i, j):\n        if (i, j) in dp:\n            return dp[(i, j)]\n        \n        if j == len(p):\n            return i == len(s)\n        \n        first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')\n        \n        if j + 1 < len(p) and p[j + 1] == '*':\n            result = (dfs(i, j + 2) or  # match 0 occurrences\n                     (first_match and dfs(i + 1, j)))  # match 1+ occurrences\n        else:\n            result = first_match and dfs(i + 1, j + 1)\n        \n        dp[(i, j)] = result\n        return result\n    \n    return dfs(0, 0)", "test": "def check(candidate):\n    assert candidate('aa', 'a') == False\n    assert candidate('aa', 'a*') == True\n    assert candidate('ab', '.*') == True\n    assert candidate('aab', 'c*a*b') == True\n    assert candidate('mississippi', 'mis*is*p*.') == False\n    assert candidate('', '') == True\n    assert candidate('', 'a*') == True\n    assert candidate('a', 'ab*') == True"}}
{"timestamp_utc": "2025-09-29T08:33:27.121967", "dataset_file": "testbench.jsonl", "dataset_index": 54, "question": "def serialize_deserialize_tree(root) -> str:\n    \"\"\"\n    Design an algorithm to serialize and deserialize a binary tree.\n    Represent tree as: TreeNode with val, left, right attributes.\n    Return serialized string that can uniquely reconstruct the tree.\n    \n    Use format: \"1,2,None,None,3,4,None,None,5,None,None\"\n    None represents null nodes in preorder traversal.\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 32.39615821838379, "response": "```python\ndef serialize_deserialize_tree(root) -> str:\n    def helper(node):\n        if node is None:\n            return ['None']\n        return [str(node.val)] + helper(node.left) + helper(node.right)\n    return ','.join(helper(root))\n```", "error": null, "raw_item": {"task_id": "CustomEval/176", "prompt": "def serialize_deserialize_tree(root) -> str:\n    \"\"\"\n    Design an algorithm to serialize and deserialize a binary tree.\n    Represent tree as: TreeNode with val, left, right attributes.\n    Return serialized string that can uniquely reconstruct the tree.\n    \n    Use format: \"1,2,None,None,3,4,None,None,5,None,None\"\n    None represents null nodes in preorder traversal.\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "serialize_deserialize_tree", "canonical_solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef serialize(root):\n    def preorder(node):\n        if not node:\n            vals.append(\"None\")\n        else:\n            vals.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n    \n    vals = []\n    preorder(root)\n    return ','.join(vals)\n\ndef deserialize(data):\n    def build_tree():\n        val = next(vals)\n        if val == \"None\":\n            return None\n        \n        node = TreeNode(int(val))\n        node.left = build_tree()\n        node.right = build_tree()\n        return node\n    \n    vals = iter(data.split(','))\n    return build_tree()\n\ndef serialize_deserialize_tree(root):\n    serialized = serialize(root)\n    deserialized = deserialize(serialized)\n    return serialized", "test": "def check(candidate):\n    # Test with simple tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    \n    result = candidate(root)\n    assert '1,2,None,None,3,None,None' == result\n    \n    # Test with None\n    assert candidate(None) == 'None'\n    \n    # Test single node\n    single = TreeNode(5)\n    assert candidate(single) == '5,None,None'"}}
{"timestamp_utc": "2025-09-29T08:33:56.698655", "dataset_file": "testbench.jsonl", "dataset_index": 55, "question": "def word_break(s: str, word_dict: list) -> bool:\n    \"\"\"\n    Determine if string can be segmented into dictionary words.\n    \n    Examples:\n    word_break('leetcode', ['leet','code']) => True\n    word_break('applepenapple', ['apple','pen']) => True\n    word_break('catsandog', ['cats','dog','sand','and','cat']) => False\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 28.5741708278656, "response": "```python\ndef word_break(s: str, word_dict: list) -> bool:\n    word_set = set(word_dict)\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[n]\n```", "error": null, "raw_item": {"task_id": "CustomEval/177", "prompt": "def word_break(s: str, word_dict: list) -> bool:\n    \"\"\"\n    Determine if string can be segmented into dictionary words.\n    \n    Examples:\n    word_break('leetcode', ['leet','code']) => True\n    word_break('applepenapple', ['apple','pen']) => True\n    word_break('catsandog', ['cats','dog','sand','and','cat']) => False\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "word_break", "canonical_solution": "def word_break(s: str, word_dict: list) -> bool:\n    word_set = set(word_dict)\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[n]", "test": "def check(candidate):\n    assert candidate('leetcode', ['leet','code']) == True\n    assert candidate('applepenapple', ['apple','pen']) == True\n    assert candidate('catsandog', ['cats','dog','sand','and','cat']) == False\n    assert candidate('', []) == True\n    assert candidate('a', ['a']) == True\n    assert candidate('ab', ['a','b']) == True\n    assert candidate('abc', ['ab','bc']) == False"}}
{"timestamp_utc": "2025-09-29T08:34:12.929605", "dataset_file": "testbench.jsonl", "dataset_index": 56, "question": "def n_queens(n: int) -> int:\n    \"\"\"\n    Count the number of solutions to the N-Queens problem.\n    Place n queens on nn chessboard so no two attack each other.\n    \n    Examples:\n    n_queens(4) => 2\n    n_queens(1) => 1\n    n_queens(8) => 92\n    \n    Return only the Python function code, no explanations.\n    \"\"\"", "provider": "grok", "model": "grok-4", "region": null, "success": true, "response_time": 15.228976726531982, "response": "```python\ndef n_queens(n: int) -> int:\n    def backtrack(row):\n        if row == n:\n            nonlocal count\n            count += 1\n            return\n        for col in range(n):\n            if col not in cols and (row - col) not in diag1 and (row + col) not in diag2:\n                cols.add(col)\n                diag1.add(row - col)\n                diag2.add(row + col)\n                backtrack(row + 1)\n                cols.remove(col)\n                diag1.remove(row - col)\n                diag2.remove(row + col)\n\n    count = 0\n    cols = set()\n    diag1 = set()\n    diag2 = set()\n    backtrack(0)\n    return count\n```", "error": null, "raw_item": {"task_id": "CustomEval/178", "prompt": "def n_queens(n: int) -> int:\n    \"\"\"\n    Count the number of solutions to the N-Queens problem.\n    Place n queens on nn chessboard so no two attack each other.\n    \n    Examples:\n    n_queens(4) => 2\n    n_queens(1) => 1\n    n_queens(8) => 92\n    \n    Return only the Python function code, no explanations.\n    \"\"\"\n", "entry_point": "n_queens", "canonical_solution": "def n_queens(n: int) -> int:\n    def is_safe(board, row, col):\n        # Check column\n        for i in range(row):\n            if board[i] == col:\n                return False\n        \n        # Check diagonals\n        for i in range(row):\n            if abs(board[i] - col) == abs(i - row):\n                return False\n        \n        return True\n    \n    def solve(board, row):\n        if row == n:\n            return 1\n        \n        count = 0\n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row] = col\n                count += solve(board, row + 1)\n                board[row] = -1\n        \n        return count\n    \n    board = [-1] * n\n    return solve(board, 0)", "test": "def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(4) == 2\n    assert candidate(8) == 92\n    assert candidate(0) == 1\n    assert candidate(2) == 0\n    assert candidate(3) == 0"}}
